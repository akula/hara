
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <link rel="shortcut icon" href="favicon.ico">
  <title>hara.event - event signalling and conditional restart</title>
  <script src="js/highlight.min.js"></script>
  <script src="js/gumshoe.min.js"></script>
  <script src="js/smooth-scroll.min.js"></script>
  
  <!-- CSS -->
  <link rel="stylesheet" href="css/poole.css">
  <link rel="stylesheet" href="css/syntax.css">
  <link rel="stylesheet" href="css/lanyon.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">
  
  <style>
  .error {
  font-weight: bold;
}

.error.version {
  color: #ac4142;
  text-decoration: line-through;
}

.api .entry pre.error {
  background-color: #ac4142;
}
.api .entry pre.error h6 {
  color: white;
  float: left;
}

.api .entry-description
{
 display: block;
 }
 
.api ul
{
  list-style-type: none;
  padding-left: 5px;
}

.api .entry-description h4
{
  height 30px;
  margin-top: 2rem;
  font-size: larger;
 }

.api .entry-description p
{
 margin-bottom: 0px;
 margin-top: 0px;
 }

.api .entry-option h6
{
 padding-right:5px;
 padding-top: 0.6em;
 margin-top: 0;
 }

.api .entry-option .args
{
 font-weight: lighter;
 }
 
.api .entry pre
 {
   width: 100%;
}
  
.api pre h6
{
 float: right;
 font-size: small;
 margin-top: 0;
 }
 
 pre.source {
  position: absolute;
  visibility: hidden;
  opacity: 0;
  height: 0px;
  transition: visibility 0s, opacity 1s linear;
 }

.api input.source-toggle{
  display: none;
}

.api label.source-toggle {
  position: relative;
  float: right;
  top: -1.9em;
  right: 2em;
  color: #ac4142;
  font-style: italic;
  cursor: pointer;
}

.api input[type="checkbox"] + label:after {
  content: "show";
}
.api input[type="checkbox"]:checked + label:after {
  content: "hide";
}

.api input[type="checkbox"]:checked ~ pre.source {
  position: relative;
  height: auto;
  visibility: visible;
  opacity: 1;
}
 
 
 
  html {
  font-size: 15px;
}

h2 {
  margin-top: 2.5rem;
  font-size: 1.5rem;
  margin-bottom: 1rem;
}

h3 {
  margin-top: 2.5rem;
}

.top {
  margin-top: 0.5em;
  display: block;
  font-size: 1.4em;
  font-style: italic;
}

.top.active {
  text-decoration: underline;
}

.heading {
  display: flex;
  padding-bottom: 1em;
}
.heading h5 {
  font-size: 0.8rem; 
  margin-top: 0.2em;
  margin-bottom: 0.2em
}

.toc ul{
  list-style-type: none;
  padding-left: 0;
}

.toc a h4 {
  color: #ac4142;
}

.toc a h5 {
  color: #ac4142;
  font-size: 0.8rem;
  margin-top: 0.1em;
  margin-bottom: 0.2em;
  padding-left: 0.8em;
}

.outline .toc{
  display: none;
}

.sidebar {
  font-size: 0.9rem;
  line-height: 1.3;
}

.sidebar-nav-item {
    display: block;
    padding-top: 0rem;
    padding-bottom: 0rem; 
    border-top: none;
}

.sidebar-nav {
    border-bottom: none;
}

pre{
  border: solid 1px;
  border-color: #f0f0f0;
  background-color: white;
}


.code .failed
{
  background-color:#ac4142; 
  padding: 10px;
  font-size: large;
}

.code .failed h5
{
  color: white;
  margin-top: 0;
  margin-botton: 0;
  font-size: small;
}

.code .failed h4
{  
  color: white;
  font-style: italic;
}

.code .failed hr
{
  margin-top: 15px;
  margin-bottom: 0px;
}

.masthead a
{
  font-size: 1.8em;
}

@media (max-width: 48rem){
.masthead-title {
    text-align: left;
}}

@media (max-width: 40rem){
.masthead-title {
    text-align: center;
}
.masthead a
{
  font-size: x-large;
}
}



@media (min-width: 38rem){
.container {
    max-width: 37rem;
    margin-left: 6rem;
 }
}

@media (min-width: 56rem){
.container {
    max-width: 54rem;
}
.page {
  margin-right: 15rem;
}
}

@media (min-width: 60rem){
.outline .toc{
  display: block;
  padding-left: 2em;
  position: fixed;
  right: 1em;
  top: 1em;
  width: 18em;
  background-color: white;
  border: solid 1px #f0f0f0;
}
.outline .toc li.active a.chapter h4{
  font-size: larger;
  font-style: italic;
}

.outline .toc li .section{
  display: none;
}

.outline .toc li.active .section{
  display: inherit;
}

.outline .toc li.active a.active.chapter h4{
  text-decoration: underline;
}

.outline .toc li.active a.active.section h5{
  text-decoration: underline;
}
}


@media (min-width: 70rem){
.container {
    max-width: 66rem;
}}
  /*

Original highlight.js style (c) Ivan Sagalaev <maniac@softwaremaniacs.org>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
}


/* Base color: saturation 0; */

.hljs,
.hljs-subst {
  color: #444;
}

.hljs-comment {
  color: #888888;
}

.hljs-keyword,
.hljs-attribute,
.hljs-selector-tag,
.hljs-meta-keyword,
.hljs-doctag,
.hljs-name {
  font-weight: bold;
}


/* User color: hue: 0 */

.hljs-type,
.hljs-string,
.hljs-number,
.hljs-selector-id,
.hljs-selector-class,
.hljs-quote,
.hljs-template-tag,
.hljs-deletion {
  color: #880000;
}

.hljs-title,
.hljs-section {
  color: #880000;
  font-weight: bold;
}

.hljs-regexp,
.hljs-symbol,
.hljs-variable,
.hljs-template-variable,
.hljs-link,
.hljs-selector-attr,
.hljs-selector-pseudo {
  color: #BC6060;
}


/* Language color: hue: 90; */

.hljs-literal {
  color: #78A960;
}

.hljs-built_in,
.hljs-bullet,
.hljs-code,
.hljs-addition {
  color: #397300;
}


/* Meta color: hue: 200 */

.hljs-meta {
  color: #1f7199;
}

.hljs-meta-string {
  color: #4d99bf;
}


/* Misc effects */

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}
  </style>
  <!-- Icons -->
</head>


  <body class="theme-base-08">
    <span id="page-top"></span>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <nav class="sidebar-nav">
    <a class="sidebar-nav-item header" href="index.html"><img src="img/logo-white.png"/></a>
    <span>&nbsp;</span>
    <a class="sidebar-nav-item" href="hara-class.html">class</a><a class="sidebar-nav-item" href="hara-common.html">common</a><a class="sidebar-nav-item" href="hara-component.html">component</a><a class="sidebar-nav-item" href="hara-concurrent.html">concurrent</a><a class="sidebar-nav-item" href="hara-concurrent-ova.html">concurrent.ova</a><a class="sidebar-nav-item" href="hara-concurrent-procedure.html">concurrent.procedure</a><a class="sidebar-nav-item" href="hara-data.html">data</a><a class="sidebar-nav-item active" href="hara-event.html">event</a><a class="sidebar-nav-item" href="hara-expression.html">expression</a><a class="sidebar-nav-item" href="hara-extend.html">extend</a><a class="sidebar-nav-item" href="hara-function.html">function</a><a class="sidebar-nav-item" href="hara-group.html">group</a><a class="sidebar-nav-item" href="hara-io.html">io</a><a class="sidebar-nav-item" href="hara-io-file.html">io.file</a><a class="sidebar-nav-item" href="hara-io-scheduler.html">io.scheduler</a><a class="sidebar-nav-item" href="hara-io-watch.html">io.watch</a><a class="sidebar-nav-item" href="hara-namespace.html">namespace</a><a class="sidebar-nav-item" href="hara-object.html">object</a><a class="sidebar-nav-item" href="hara-reflect.html">reflect</a><a class="sidebar-nav-item" href="hara-sort.html">sort</a><a class="sidebar-nav-item" href="hara-string.html">string</a><a class="sidebar-nav-item" href="hara-test.html">test</a><a class="sidebar-nav-item" href="hara-time.html">time</a><a class="sidebar-nav-item" href="hara-zip.html">zip</a>
    <span class="sidebar-nav-item">&nbsp;</span>
    <span class="sidebar-nav-item">&nbsp;</span>
  </nav>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">hara.event</a>
            <small>event signalling and conditional restart</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="page">
          <div class="heading">
            <div>
              <h5>Author: Chris Zheng&nbsp;&nbsp;<a href="mailto:z@caudate.me">(z@caudate.me)</a></h5>
              <h5>Date: 03 October 2016</h5>
              <h5>Repository: <a href="https://github.com/zcaudate/hara">https://github.com/zcaudate/hara</a></h5>
              <h5>Version: 2.4.5</h5></div></div>
          <hr/>
          <div class="outline">
            <div class="toc">
              <nav data-gumshoe-header>
                <ul data-gumshoe>
                  <a data-scroll class="top" href="#page-top">TOP</a>
                  <li><a class="chapter" data-scroll="" href="#introduction"><h4>1 &nbsp; Introduction</h4></a><a class="section" data-scroll="" href="#installation"><h5><i>1.1 &nbsp; Installation</i></h5></a><a class="section" data-scroll="" href="#motivation"><h5><i>1.2 &nbsp; Motivation</i></h5></a><a class="section" data-scroll="" href="#other-libraries"><h5><i>1.3 &nbsp; Other Libraries</i></h5></a></li><li><a class="chapter" data-scroll="" href="#api"><h4>2 &nbsp; API</h4></a><a class="section" data-scroll="" href="#entry__hara_event__choose"><h5><i>choose</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__clear_listeners"><h5><i>clear-listeners</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__continue"><h5><i>continue</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__default"><h5><i>default</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__deflistener"><h5><i>deflistener</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__escalate"><h5><i>escalate</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__fail"><h5><i>fail</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__install_listener"><h5><i>install-listener</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__list_listeners"><h5><i>list-listeners</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__manage"><h5><i>manage</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__raise"><h5><i>raise</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__signal"><h5><i>signal</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__uninstall_listener"><h5><i>uninstall-listener</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__with_temp_listener"><h5><i>with-temp-listener</i></h5></a></li><li><a class="chapter" data-scroll="" href="#event-management"><h4>3 &nbsp; Event Management</h4></a><a class="section" data-scroll="" href="#listeners-and-managers"><h5><i>3.1 &nbsp; Listeners and Managers</i></h5></a><a class="section" data-scroll="" href="#listener-syntax"><h5><i>3.2 &nbsp; Listener Syntax</i></h5></a><a class="section" data-scroll="" href="#signal-syntax"><h5><i>3.3 &nbsp; Signal Syntax</i></h5></a><a class="section" data-scroll="" href="#raise-syntax"><h5><i>3.4 &nbsp; Raise Syntax</i></h5></a><a class="section" data-scroll="" href="#manage-syntax"><h5><i>3.5 &nbsp; Manage Syntax</i></h5></a></li><li><a class="chapter" data-scroll="" href="#quickstart"><h4>4 &nbsp; Quickstart</h4></a><a class="section" data-scroll="" href="#unlucky-numbers"><h5><i>4.1 &nbsp; Unlucky Numbers</i></h5></a><a class="section" data-scroll="" href="#getting-messy"><h5><i>4.2 &nbsp; Getting Messy</i></h5></a><a class="section" data-scroll="" href="#raise-dont-throw"><h5><i>4.3 &nbsp; Raise, don't Throw</i></h5></a><a class="section" data-scroll="" href="#issues-and-abnormal-flow"><h5><i>4.4 &nbsp; Issues and Abnormal Flow</i></h5></a><a class="section" data-scroll="" href="#a-sleight-of-hand"><h5><i>4.5 &nbsp; A Sleight of Hand</i></h5></a><a class="section" data-scroll="" href="#chinese-unlucky-numbers"><h5><i>4.6 &nbsp; Chinese Unlucky Numbers</i></h5></a><a class="section" data-scroll="" href="#christian-unlucky-numbers"><h5><i>4.7 &nbsp; Christian Unlucky Numbers</i></h5></a></li><li><a class="chapter" data-scroll="" href="#guides"><h4>5 &nbsp; Guides</h4></a><a class="section" data-scroll="" href="#api-raise"><h5><i>5.1 &nbsp; raise</i></h5></a><a class="section" data-scroll="" href="#option--default"><h5><i>5.2 &nbsp; option/default</i></h5></a><a class="section" data-scroll="" href="#manage--on"><h5><i>5.3 &nbsp; manage/on</i></h5></a><a class="section" data-scroll="" href="#checkers"><h5><i>5.4 &nbsp; checkers</i></h5></a><a class="section" data-scroll="" href="#bindings"><h5><i>5.5 &nbsp; bindings</i></h5></a><a class="section" data-scroll="" href="#catch-and-finally"><h5><i>5.6 &nbsp; catch and finally</i></h5></a><a class="section" data-scroll="" href="#special-forms"><h5><i>5.7 &nbsp; special forms</i></h5></a><a class="section" data-scroll="" href="#api-continue"><h5><i>5.8 &nbsp; continue</i></h5></a><a class="section" data-scroll="" href="#api-fail"><h5><i>5.9 &nbsp; fail</i></h5></a><a class="section" data-scroll="" href="#api-choose"><h5><i>5.10 &nbsp; choose</i></h5></a><a class="section" data-scroll="" href="#api-default"><h5><i>5.11 &nbsp; default</i></h5></a><a class="section" data-scroll="" href="#api-escalate"><h5><i>5.12 &nbsp; escalate</i></h5></a></li><li><a class="chapter" data-scroll="" href="#strategies"><h4>6 &nbsp; Strategies</h4></a><a class="section" data-scroll="" href="#normal"><h5><i>6.1 &nbsp; Normal</i></h5></a><a class="section" data-scroll="" href="#catch"><h5><i>6.2 &nbsp; Catch</i></h5></a><a class="section" data-scroll="" href="#continue"><h5><i>6.3 &nbsp; Continue</i></h5></a><a class="section" data-scroll="" href="#choose"><h5><i>6.4 &nbsp; Choose</i></h5></a><a class="section" data-scroll="" href="#choose-more"><h5><i>6.5 &nbsp; Choose - More Strategies</i></h5></a><a class="section" data-scroll="" href="#escalate"><h5><i>6.6 &nbsp; Escalate</i></h5></a><a class="section" data-scroll="" href="#fail"><h5><i>6.7 &nbsp; Fail</i></h5></a><a class="section" data-scroll="" href="#default"><h5><i>6.8 &nbsp; Default</i></h5></a><a class="section" data-scroll="" href="#on-form"><h5><i>6.9 &nbsp; Branch Using On</i></h5></a></li><li><a class="chapter" data-scroll="" href="#implementation"><h4>7 &nbsp; Implementation</h4></a><a class="section" data-scroll="" href="#the-dumb-throw"><h5><i>7.1 &nbsp; The dumb throw</i></h5></a><a class="section" data-scroll="" href="#the-smart-raise"><h5><i>7.2 &nbsp; The smart raise</i></h5></a><a class="section" data-scroll="" href="#being-proactive"><h5><i>7.3 &nbsp; Being Proactive</i></h5></a><a class="section" data-scroll="" href="#the-issue-management-board"><h5><i>7.4 &nbsp; The Issue Management Board</i></h5></a><a class="section" data-scroll="" href="#control-flow-as-data"><h5><i>7.5 &nbsp; Control Flow as Data</i></h5></a><a class="section" data-scroll="" href="#implementing-catch"><h5><i>7.6 &nbsp; Implementing Catch</i></h5></a><a class="section" data-scroll="" href="#implementing-choose"><h5><i>7.7 &nbsp; Implementing Choose</i></h5></a><a class="section" data-scroll="" href="#implementing-the-rest"><h5><i>7.8 &nbsp; Implementing the Rest</i></h5></a></li><li><a class="chapter" data-scroll="" href="#links-and-resources"><h4>8 &nbsp; Links and Resources</h4></a></li>
                </ul>
              </nav>
            </div>
          </div>

          <div class="toc">
              <nav>
                <ul>
                  <li><a class="chapter" data-scroll="" href="#introduction"><h4>1 &nbsp; Introduction</h4></a><a class="section" data-scroll="" href="#installation"><h5><i>1.1 &nbsp; Installation</i></h5></a><a class="section" data-scroll="" href="#motivation"><h5><i>1.2 &nbsp; Motivation</i></h5></a><a class="section" data-scroll="" href="#other-libraries"><h5><i>1.3 &nbsp; Other Libraries</i></h5></a></li><li><a class="chapter" data-scroll="" href="#api"><h4>2 &nbsp; API</h4></a><a class="section" data-scroll="" href="#entry__hara_event__choose"><h5><i>choose</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__clear_listeners"><h5><i>clear-listeners</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__continue"><h5><i>continue</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__default"><h5><i>default</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__deflistener"><h5><i>deflistener</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__escalate"><h5><i>escalate</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__fail"><h5><i>fail</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__install_listener"><h5><i>install-listener</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__list_listeners"><h5><i>list-listeners</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__manage"><h5><i>manage</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__raise"><h5><i>raise</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__signal"><h5><i>signal</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__uninstall_listener"><h5><i>uninstall-listener</i></h5></a><a class="section" data-scroll="" href="#entry__hara_event__with_temp_listener"><h5><i>with-temp-listener</i></h5></a></li><li><a class="chapter" data-scroll="" href="#event-management"><h4>3 &nbsp; Event Management</h4></a><a class="section" data-scroll="" href="#listeners-and-managers"><h5><i>3.1 &nbsp; Listeners and Managers</i></h5></a><a class="section" data-scroll="" href="#listener-syntax"><h5><i>3.2 &nbsp; Listener Syntax</i></h5></a><a class="section" data-scroll="" href="#signal-syntax"><h5><i>3.3 &nbsp; Signal Syntax</i></h5></a><a class="section" data-scroll="" href="#raise-syntax"><h5><i>3.4 &nbsp; Raise Syntax</i></h5></a><a class="section" data-scroll="" href="#manage-syntax"><h5><i>3.5 &nbsp; Manage Syntax</i></h5></a></li><li><a class="chapter" data-scroll="" href="#quickstart"><h4>4 &nbsp; Quickstart</h4></a><a class="section" data-scroll="" href="#unlucky-numbers"><h5><i>4.1 &nbsp; Unlucky Numbers</i></h5></a><a class="section" data-scroll="" href="#getting-messy"><h5><i>4.2 &nbsp; Getting Messy</i></h5></a><a class="section" data-scroll="" href="#raise-dont-throw"><h5><i>4.3 &nbsp; Raise, don't Throw</i></h5></a><a class="section" data-scroll="" href="#issues-and-abnormal-flow"><h5><i>4.4 &nbsp; Issues and Abnormal Flow</i></h5></a><a class="section" data-scroll="" href="#a-sleight-of-hand"><h5><i>4.5 &nbsp; A Sleight of Hand</i></h5></a><a class="section" data-scroll="" href="#chinese-unlucky-numbers"><h5><i>4.6 &nbsp; Chinese Unlucky Numbers</i></h5></a><a class="section" data-scroll="" href="#christian-unlucky-numbers"><h5><i>4.7 &nbsp; Christian Unlucky Numbers</i></h5></a></li><li><a class="chapter" data-scroll="" href="#guides"><h4>5 &nbsp; Guides</h4></a><a class="section" data-scroll="" href="#api-raise"><h5><i>5.1 &nbsp; raise</i></h5></a><a class="section" data-scroll="" href="#option--default"><h5><i>5.2 &nbsp; option/default</i></h5></a><a class="section" data-scroll="" href="#manage--on"><h5><i>5.3 &nbsp; manage/on</i></h5></a><a class="section" data-scroll="" href="#checkers"><h5><i>5.4 &nbsp; checkers</i></h5></a><a class="section" data-scroll="" href="#bindings"><h5><i>5.5 &nbsp; bindings</i></h5></a><a class="section" data-scroll="" href="#catch-and-finally"><h5><i>5.6 &nbsp; catch and finally</i></h5></a><a class="section" data-scroll="" href="#special-forms"><h5><i>5.7 &nbsp; special forms</i></h5></a><a class="section" data-scroll="" href="#api-continue"><h5><i>5.8 &nbsp; continue</i></h5></a><a class="section" data-scroll="" href="#api-fail"><h5><i>5.9 &nbsp; fail</i></h5></a><a class="section" data-scroll="" href="#api-choose"><h5><i>5.10 &nbsp; choose</i></h5></a><a class="section" data-scroll="" href="#api-default"><h5><i>5.11 &nbsp; default</i></h5></a><a class="section" data-scroll="" href="#api-escalate"><h5><i>5.12 &nbsp; escalate</i></h5></a></li><li><a class="chapter" data-scroll="" href="#strategies"><h4>6 &nbsp; Strategies</h4></a><a class="section" data-scroll="" href="#normal"><h5><i>6.1 &nbsp; Normal</i></h5></a><a class="section" data-scroll="" href="#catch"><h5><i>6.2 &nbsp; Catch</i></h5></a><a class="section" data-scroll="" href="#continue"><h5><i>6.3 &nbsp; Continue</i></h5></a><a class="section" data-scroll="" href="#choose"><h5><i>6.4 &nbsp; Choose</i></h5></a><a class="section" data-scroll="" href="#choose-more"><h5><i>6.5 &nbsp; Choose - More Strategies</i></h5></a><a class="section" data-scroll="" href="#escalate"><h5><i>6.6 &nbsp; Escalate</i></h5></a><a class="section" data-scroll="" href="#fail"><h5><i>6.7 &nbsp; Fail</i></h5></a><a class="section" data-scroll="" href="#default"><h5><i>6.8 &nbsp; Default</i></h5></a><a class="section" data-scroll="" href="#on-form"><h5><i>6.9 &nbsp; Branch Using On</i></h5></a></li><li><a class="chapter" data-scroll="" href="#implementation"><h4>7 &nbsp; Implementation</h4></a><a class="section" data-scroll="" href="#the-dumb-throw"><h5><i>7.1 &nbsp; The dumb throw</i></h5></a><a class="section" data-scroll="" href="#the-smart-raise"><h5><i>7.2 &nbsp; The smart raise</i></h5></a><a class="section" data-scroll="" href="#being-proactive"><h5><i>7.3 &nbsp; Being Proactive</i></h5></a><a class="section" data-scroll="" href="#the-issue-management-board"><h5><i>7.4 &nbsp; The Issue Management Board</i></h5></a><a class="section" data-scroll="" href="#control-flow-as-data"><h5><i>7.5 &nbsp; Control Flow as Data</i></h5></a><a class="section" data-scroll="" href="#implementing-catch"><h5><i>7.6 &nbsp; Implementing Catch</i></h5></a><a class="section" data-scroll="" href="#implementing-choose"><h5><i>7.7 &nbsp; Implementing Choose</i></h5></a><a class="section" data-scroll="" href="#implementing-the-rest"><h5><i>7.8 &nbsp; Implementing the Rest</i></h5></a></li><li><a class="chapter" data-scroll="" href="#links-and-resources"><h4>8 &nbsp; Links and Resources</h4></a></li>
                </ul>
              </nav>
          </div>
          <div><span id="introduction" name="introduction"></span><h2><b>1 &nbsp;&nbsp; Introduction</b></h2></div><div><p><a href='https://github.com/zcaudate/hara/blob/master/src/hara/event.clj'>hara.event</a> aims to provide more loosely coupled code through two mechanisms:</p><ul><li>a global eventing system for decoupilng of side-effecting</li><li>a conditional restart framework that hooks into the eventing system.</li></ul><p><code>hara.event</code> was originally developed as a <a href='https://github.com/zcaudate/ribol'>separate library</a> but has been included as part of the larger <a href='https://github.com/zcaudate/hara'>hara</a> codebase. The main addition to the original library has been the inclusion of the eventing system as it was felt that there should be an integrated way of dealing with side-effecting calls such as logging, indexing, emails and many other tasks within both normal and abnormal program flows.</p></div><div><span id="installation" name="installation"></span><h3>1.1 &nbsp;&nbsp; Installation</h3></div><div><p>Add to <code>project.clj</code> dependencies:</p><pre><code>&#91;im.chit/hara.event &quot;2.4.5&quot;&#93;</code></pre></div><div><p>All functionality is found contained in the <code>hara.event</code> namespace</p></div><div class="code"><pre><code class="clojure">(use 'hara.event)</code></pre></div><div><span id="motivation" name="motivation"></span><h3>1.2 &nbsp;&nbsp; Motivation</h3></div><div><p>For those that are not familiar with restart systems (most well know in Common Lisp), they can be thought of as an issue resolution system or <code>try++/catch++</code>. In <code>hara.event</code>, we use the term <code>issues</code> to differentiate them from <code>exceptions</code>. The difference is purely semantic: <code>issues</code> are <code>managed</code> whilst <code>exceptions</code> are <code>caught</code>. They all refer to abnormal program flow. Conditional restarts provide a way for the top-level application to more cleanly deal with <em>Type 2</em> exceptions.</p></div><div><span id="other-libraries" name="other-libraries"></span><h3>1.3 &nbsp;&nbsp; Other Libraries</h3></div><div><p>There are currently three other conditional restart libraries for clojure, in the more traditional Common Lisp style syntax:</p><ul><li><a href='https://github.com/richhickey/clojure-contrib/blob/master/src/main/clojure/clojure/contrib/error_kit.clj'>errorkit</a> was the first and provided the guiding architecture for this library.</li><li><a href='https://github.com/hugoduncan/swell'>swell</a> and <a href='https://github.com/bwo/conditions'>conditions</a> have been written to work with <a href='https://github.com/scgilardi/slingshot'>slingshot</a>.</li></ul></div><div><span id="api" name="api"></span><h2><b>2 &nbsp;&nbsp; API</b></h2></div><div class="api"><span id="entry__hara_event__"></span><hr /><div><ul><li><a data-scroll="" href="#entry__hara_event__choose">choose</a></li><li><a data-scroll="" href="#entry__hara_event__clear_listeners">clear-listeners</a></li><li><a data-scroll="" href="#entry__hara_event__continue">continue</a></li><li><a data-scroll="" href="#entry__hara_event__default">default</a></li><li><a data-scroll="" href="#entry__hara_event__deflistener">deflistener</a></li><li><a data-scroll="" href="#entry__hara_event__escalate">escalate</a></li><li><a data-scroll="" href="#entry__hara_event__fail">fail</a></li><li><a data-scroll="" href="#entry__hara_event__install_listener">install-listener</a></li><li><a data-scroll="" href="#entry__hara_event__list_listeners">list-listeners</a></li><li><a data-scroll="" href="#entry__hara_event__manage">manage</a></li><li><a data-scroll="" href="#entry__hara_event__raise">raise</a></li><li><a data-scroll="" href="#entry__hara_event__signal">signal</a></li><li><a data-scroll="" href="#entry__hara_event__uninstall_listener">uninstall-listener</a></li><li><a data-scroll="" href="#entry__hara_event__with_temp_listener">with-temp-listener</a></li></ul><hr style="margin-bottom: 0" /><div><div class="entry"><span id="entry__hara_event__choose"></span><div class="entry-description"><h4><b>choose&nbsp<a data-scroll="" href="#entry__hara_event__">^</a></b></h4><p><i>used within a manage form to definitively fail the system</i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/event.clj#L140-L151" target="_blank">v&nbsp;2.2</a>&nbsp;&nbsp;args: <i class="args">[label & args]</i>&nbsp;&nbsp;&nbsp;</h6><div><input class="source-toggle" id="entry__pre_hara_event__choose" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_event__choose"></label><pre class="source"><code class="clojure">(defmacro choose
  [label & args]
  `{:type :choose :label ~label :args (list ~@args)})</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/event_test.clj#L113-L120" target="_blank">link</a></i></h6><code class="clojure">(manage (raise :error
               (option :specify [a] a))
        (on :error
            _
            (choose :specify 42)))
=> 42</code></pre></div><div class="entry"><span id="entry__hara_event__clear_listeners"></span><div class="entry-description"><h4><b>clear-listeners&nbsp<a data-scroll="" href="#entry__hara_event__">^</a></b></h4><p><i>empties all event listeners</i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/event.clj#L15-L19" target="_blank">v&nbsp;2.2</a>&nbsp;&nbsp;args: <i class="args">[]</i>&nbsp;&nbsp;&nbsp;</h6><div><input class="source-toggle" id="entry__pre_hara_event__clear_listeners" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_event__clear_listeners"></label><pre class="source"><code class="clojure">(defn clear-listeners
  []
  (reset! *signal-manager* (common/manager)))</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/event_test.clj#L6-L6" target="_blank">link</a></i></h6><code class="clojure"></code></pre></div><div class="entry"><span id="entry__hara_event__continue"></span><div class="entry-description"><h4><b>continue&nbsp<a data-scroll="" href="#entry__hara_event__">^</a></b></h4><p><i>used within a manage form to continue on with a particular value</i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/event.clj#L108-L118" target="_blank">v&nbsp;2.2</a>&nbsp;&nbsp;args: <i class="args">[& body]</i>&nbsp;&nbsp;&nbsp;</h6><div><input class="source-toggle" id="entry__pre_hara_event__continue" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_event__continue"></label><pre class="source"><code class="clojure">(defmacro continue
  [& body]
  `{:type :continue :value (do ~@body)})</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/event_test.clj#L87-L93" target="_blank">link</a></i></h6><code class="clojure">(manage [1 2 (raise {:error "should be 3"})]
        (on :error
            _
            (continue 3)))
=> [1 2 3]</code></pre></div><div class="entry"><span id="entry__hara_event__default"></span><div class="entry-description"><h4><b>default&nbsp<a data-scroll="" href="#entry__hara_event__">^</a></b></h4><p><i>used within either a raise or escalate form to specify the default option to take if no other options arise. </i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/event.clj#L120-L138" target="_blank">v&nbsp;2.2</a>&nbsp;&nbsp;args: <i class="args">[& args]</i>&nbsp;&nbsp;&nbsp;</h6><div><input class="source-toggle" id="entry__pre_hara_event__default" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_event__default"></label><pre class="source"><code class="clojure">(defmacro default
  [& args]
  `{:type :default :args (list ~@args)})</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/event_test.clj#L96-L110" target="_blank">link</a></i></h6><code class="clojure">(raise :error
       (option :specify [a] a)
       (default :specify 3))
=> 3

(manage
 (raise :error
        (option :specify [a] a)
        (default :specify 3))
 (on :error []
     (escalate :error
               (default :specify 5))))
=> 5</code></pre></div><div class="entry"><span id="entry__hara_event__deflistener"></span><div class="entry-description"><h4><b>deflistener&nbsp<a data-scroll="" href="#entry__hara_event__">^</a></b></h4><p><i>installs a global signal listener</i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/event.clj#L64-L88" target="_blank">v&nbsp;2.2</a>&nbsp;&nbsp;args: <i class="args">[name checker bindings & more]</i>&nbsp;&nbsp;&nbsp;</h6><div><input class="source-toggle" id="entry__pre_hara_event__deflistener" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_event__deflistener"></label><pre class="source"><code class="clojure">(defmacro deflistener
  [name checker bindings & more]
  (let [sym    (str  (.getName *ns*) "/" name)
        cform  (common/checker-form checker)
        hform  (common/handler-form bindings more)]
    `(do (install-listener (symbol ~sym) ~cform ~hform)
         (def ~(symbol name) (symbol ~sym)))))</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/event_test.clj#L33-L50" target="_blank">link</a></i></h6><code class="clojure">(def ^:dynamic *global* (atom {}))

(deflistener count-listener :log
  [msg]
  (swap! *global* update-in [:counts] (fnil #(conj % (count msg)) [])))

(signal [:log {:msg "Hello World"}])
(raise  [:log {:msg "How are you?"}]
        (option :nil [] nil)
        (default :nil))

@*global*
=> {:counts [11 12]}</code></pre></div><div class="entry"><span id="entry__hara_event__escalate"></span><div class="entry-description"><h4><b>escalate&nbsp<a data-scroll="" href="#entry__hara_event__">^</a></b></h4><p><i>used within a manage form to add further data on an issue</i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/event.clj#L166-L183" target="_blank">v&nbsp;2.2</a>&nbsp;&nbsp;args: <i class="args">[data & forms]</i>&nbsp;&nbsp;&nbsp;</h6><div><input class="source-toggle" id="entry__pre_hara_event__escalate" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_event__escalate"></label><pre class="source"><code class="clojure">(defmacro escalate
  [data & forms]
  (let [[data forms]
        (if (util/is-special-form :raise data)
          [nil (cons data forms)]
          [data forms])]
    `{:type :escalate
      :data ~data
      :options  ~(util/parse-option-forms forms)
      :default  ~(util/parse-default-form forms)}))</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/event_test.clj#L123-L129" target="_blank">link</a></i></h6><code class="clojure">(manage [1 2 (raise :error)]
        (on :error
            _
            (escalate :escalated)))
=> (throws)</code></pre></div><div class="entry"><span id="entry__hara_event__fail"></span><div class="entry-description"><h4><b>fail&nbsp<a data-scroll="" href="#entry__hara_event__">^</a></b></h4><p><i>used within a manage form to definitively fail the system</i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/event.clj#L153-L164" target="_blank">v&nbsp;2.2</a>&nbsp;&nbsp;args: <i class="args">[] [data]</i>&nbsp;&nbsp;&nbsp;</h6><div><input class="source-toggle" id="entry__pre_hara_event__fail" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_event__fail"></label><pre class="source"><code class="clojure">(defmacro fail
  ([] {:type :fail :data {}})
  ([data]
     `{:type :fail :data ~data}))</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/event_test.clj#L132-L138" target="_blank">link</a></i></h6><code class="clojure">(manage (raise :error)
        (on :error
            _
            (fail :failed)))
=> (throws)</code></pre></div><div class="entry"><span id="entry__hara_event__install_listener"></span><div class="entry-description"><h4><b>install-listener&nbsp<a data-scroll="" href="#entry__hara_event__">^</a></b></h4><p><i>adds an event listener, use deflistener instead</i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/event.clj#L29-L35" target="_blank">v&nbsp;2.2</a>&nbsp;&nbsp;args: <i class="args">[id checker handler]</i>&nbsp;&nbsp;&nbsp;</h6><div><input class="source-toggle" id="entry__pre_hara_event__install_listener" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_event__install_listener"></label><pre class="source"><code class="clojure">(defn install-listener
  [id checker handler]
  (swap! *signal-manager*
         common/add-handler checker {:id id
                                     :fn handler}))</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/event_test.clj#L12-L12" target="_blank">link</a></i></h6><code class="clojure"></code></pre></div><div class="entry"><span id="entry__hara_event__list_listeners"></span><div class="entry-description"><h4><b>list-listeners&nbsp<a data-scroll="" href="#entry__hara_event__">^</a></b></h4><p><i>shows all event listeners</i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/event.clj#L21-L27" target="_blank">v&nbsp;2.2</a>&nbsp;&nbsp;args: <i class="args">[] [checker]</i>&nbsp;&nbsp;&nbsp;</h6><div><input class="source-toggle" id="entry__pre_hara_event__list_listeners" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_event__list_listeners"></label><pre class="source"><code class="clojure">(defn list-listeners
  ([]
   (common/list-handlers @*signal-manager*))
  ([checker]
   (common/list-handlers @*signal-manager* checker)))</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/event_test.clj#L9-L9" target="_blank">link</a></i></h6><code class="clojure"></code></pre></div><div class="entry"><span id="entry__hara_event__manage"></span><div class="entry-description"><h4><b>manage&nbsp<a data-scroll="" href="#entry__hara_event__">^</a></b></h4><p><i>manages a raised issue, like try but is continuable:</i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/event.clj#L208-L237" target="_blank">v&nbsp;2.2</a>&nbsp;&nbsp;args: <i class="args">[& forms]</i>&nbsp;&nbsp;&nbsp;</h6><div><input class="source-toggle" id="entry__pre_hara_event__manage" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_event__manage"></label><pre class="source"><code class="clojure">(defmacro manage
  [& forms]
  (let [sp-fn           (fn [form] (util/is-special-form :manage form #{'finally 'catch}))
        body-forms      (vec (filter (complement sp-fn) forms))
        sp-forms        (filter sp-fn forms)
        id              (common/new-id)
        options         (util/parse-option-forms sp-forms)
        on-handlers     (util/parse-on-handler-forms sp-forms)
        on-any-handlers (util/parse-on-any-handler-forms sp-forms)
        try-forms       (util/parse-try-forms sp-forms)
        optmap          (zipmap (keys options) (repeat id))]
    `(let [manager# (common/manager ~id
                                    ~(vec (concat on-handlers on-any-handlers))
                                    ~options)]
       (binding [*issue-managers* (cons manager# *issue-managers*)
                 *issue-optmap*   (merge ~optmap *issue-optmap*)]
         (try
           (try
             ~@body-forms
             (catch clojure.lang.ExceptionInfo ~'ex
               (manage/manage-condition manager# ~'ex)))
           ~@try-forms)))))</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/event_test.clj#L78-L84" target="_blank">link</a></i></h6><code class="clojure">(manage [1 2 (raise {:error "should be 3"})]
        (on :error
            _
            3))
=> 3</code></pre></div><div class="entry"><span id="entry__hara_event__raise"></span><div class="entry-description"><h4><b>raise&nbsp<a data-scroll="" href="#entry__hara_event__">^</a></b></h4><p><i>raise an issue, like throw but can be conditionally managed as well as automatically resolved:</i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/event.clj#L185-L205" target="_blank">v&nbsp;2.2</a>&nbsp;&nbsp;args: <i class="args">[content & [msg & forms]]</i>&nbsp;&nbsp;&nbsp;</h6><div><input class="source-toggle" id="entry__pre_hara_event__raise" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_event__raise"></label><pre class="source"><code class="clojure">(defmacro raise
  [content & [msg & forms]]
  (let [[msg forms] (if (util/is-special-form :raise msg)
                      ["" (cons msg forms)]
                      [msg forms])
        options (util/parse-option-forms forms)
        default (util/parse-default-form forms)]
    `(let [issue# (data/issue ~content ~msg ~options ~default)]
       (signal (assoc (:data issue#) :issue (:msg issue#)))
       (raise/raise-loop issue# *issue-managers*
                         (merge (:optmap issue#) *issue-optmap*)))))</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/event_test.clj#L67-L75" target="_blank">link</a></i></h6><code class="clojure">(raise  [:error {:msg "A problem."}])
=> (throws)

(raise [:error {:msg "A resolvable problem"}]
       (option :something [] 42)
       (default :something))
=> 42</code></pre></div><div class="entry"><span id="entry__hara_event__signal"></span><div class="entry-description"><h4><b>signal&nbsp<a data-scroll="" href="#entry__hara_event__">^</a></b></h4><p><i>signals an event that is sent to, it does not do anything by itself</i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/event.clj#L90-L106" target="_blank">v&nbsp;2.2</a>&nbsp;&nbsp;args: <i class="args">[data]</i>&nbsp;&nbsp;&nbsp;</h6><div><input class="source-toggle" id="entry__pre_hara_event__signal" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_event__signal"></label><pre class="source"><code class="clojure">(defmacro signal
  [data]
  `(let [ndata#   (common/expand-data ~data)]
     (doall (for [handler# (common/match-handlers @*signal-manager* ndata#)]
              {:id (:id handler#) :result ((:fn handler#) ndata#)}))))</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/event_test.clj#L53-L64" target="_blank">link</a></i></h6><code class="clojure">(signal :anything) => ()

(deflistener hello _
  e
  e)

(signal :anything) => '({:id hara.event-test/hello :result {:anything true}})</code></pre></div><div class="entry"><span id="entry__hara_event__uninstall_listener"></span><div class="entry-description"><h4><b>uninstall-listener&nbsp<a data-scroll="" href="#entry__hara_event__">^</a></b></h4><p><i>installs a global signal listener</i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/event.clj#L37-L62" target="_blank">v&nbsp;2.2</a>&nbsp;&nbsp;args: <i class="args">[id]</i>&nbsp;&nbsp;&nbsp;</h6><div><input class="source-toggle" id="entry__pre_hara_event__uninstall_listener" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_event__uninstall_listener"></label><pre class="source"><code class="clojure">(defn uninstall-listener
  [id]
  (do (swap! *signal-manager* common/remove-handler id)
      (if-let [nsp (and (symbol? id)
                        (.getNamespace ^Symbol id)
                        (Namespace/find (symbol (.getNamespace ^Symbol id))))]
        (do (.unmap ^Namespace nsp (symbol (.getName ^Symbol id)))
            nsp)
        id)))</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/event_test.clj#L15-L30" target="_blank">link</a></i></h6><code class="clojure">(def ^:dynamic *global* (atom {}))

(deflistener count-listener :log
  [msg]
  (swap! *global* update-in [:counts] (fnil #(conj % (count msg)) [])))
(uninstall-listener count-listener)

(signal [:log {:msg "Hello World"}])
(raise  [:log {:msg "How are you?"}]
        (option :nil [] nil)
        (default :nil))

@*global*
=> {}</code></pre></div><div class="entry"><span id="entry__hara_event__with_temp_listener"></span><div class="entry-description"><h4><b>with-temp-listener&nbsp<a data-scroll="" href="#entry__hara_event__">^</a></b></h4><p><i>used for isolating and testing signaling</i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/event.clj#L239-L250" target="_blank">v&nbsp;2.4</a>&nbsp;&nbsp;args: <i class="args">[[checker handler] & body]</i>&nbsp;&nbsp;&nbsp;</h6><div><input class="source-toggle" id="entry__pre_hara_event__with_temp_listener" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_event__with_temp_listener"></label><pre class="source"><code class="clojure">(defmacro with-temp-listener
  [[checker handler] & body]
  `(binding [*signal-manager* (atom (common/manager))]
     (install-listener :temp ~checker ~handler)
     ~@body))</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/event_test.clj#L141-L146" target="_blank">link</a></i></h6><code class="clojure">(with-temp-listener [{:id string?}
                     (fn [e] "world")]
  (signal {:id "hello"}))
=> '({:result "world", :id :temp})</code></pre></div></div></div></div><div><span id="event-management" name="event-management"></span><h2><b>3 &nbsp;&nbsp; Event Management</b></h2></div><div><span id="listeners-and-managers" name="listeners-and-managers"></span><h3>3.1 &nbsp;&nbsp; Listeners and Managers</h3></div><div><p>In any program, we see the following patterns</p><ul><li>side effects occur within both abnormal and normal program flow (usually logging)</li><li>side-effecting libraries coupled to the main logic (logback, email systems, alerts)</li><li>usually some sort of logging has to be done on abnormal program flow</li></ul><p><code>hara.event</code> provides for listeners and managers:</p><ul><li>Listeners act on events they have jurisdiction over for both <code>signal</code> and <code>raise</code> calls. All listeners participate.</li><li>Managers act in a hierarchical fashion where if an issue is raised, the closest manager will handle the issue.</li></ul><p>An example is provided below:</p></div><div class="figure"><a id="example-pathways" name="example-pathways"></a><h4><i>fig.1  &nbsp;-&nbsp; example pathways</i></h4><div class="img"><img line="{:row 63, :col 1, :end-row 63, :end-col 93}" src="img/hara_event/event_pathway.png" title="example pathways" width="100%" /></div><p></p></div><div><p>The only difference between <code>signal</code> and <code>raise</code> calls is that <code>signal</code> does not trigger <code>manage</code> handlers. Both calls will trigger any compatible listener. The listers and managers act in a horizontal/vertical or only/all fashion to provide for better decoupilng of functionality within the code base.</p></div><div><span id="listener-syntax" name="listener-syntax"></span><h3>3.2 &nbsp;&nbsp; Listener Syntax</h3></div><div><p><code>deflistener</code> installs a signal listener with a precondition for activation. For example, in the case below, if there is a <code>:log</code> in body of the signalled (or raised) event, then <code>event</code> will be printed.</p></div><div class="code"><pre><code class="clojure">(deflistener print-listener :log
  event
  (println event))</code></pre></div><div><span id="signal-syntax" name="signal-syntax"></span><h3>3.3 &nbsp;&nbsp; Signal Syntax</h3></div><div><p><code>signal</code> typically just informs its listeners with a given set of information:</p></div><div class="code"><pre><code class="clojure">(signal {:everything-is-good true :input-data 3 :log true})</code></pre></div><div><p>If the previous <code>deflistener</code> was defined, then this call will activate a print statement.</p></div><div><span id="raise-syntax" name="raise-syntax"></span><h3>3.4 &nbsp;&nbsp; Raise Syntax</h3></div><div><p>Instead of <code>throw</code>, a new form <code>raise</code> is introduced (<a href='#raise-syntax'>e.3.4</a>):</p></div><div class="code"><pre><code class="clojure">(raise {:input-not-string true :input-data 3}     ;; issue payload
       (option :use-na [] &quot;NA&quot;)                   ;; option 1
       (option :use-custom [n] n)                 ;; option 2
       (default :use-custom &quot;nil&quot;))               ;; default choice</code></pre></div><div><p><code>raise</code> differs to <code>throw</code> in a few ways:</p><ul><li>issues are of type <code>clojure.lang.ExceptionInfo</code>.</li><li>the payload is a <code>hash-map</code>.</li><li><strong>optional</strong>: multiple <code>option</code> handlers can be specified.</li><li><strong>optional</strong>: a <code>default</code> choice can be specified.</li></ul></div><div><span id="manage-syntax" name="manage-syntax"></span><h3>3.5 &nbsp;&nbsp; Manage Syntax</h3></div><div><p>Instead of the <code>try/catch</code> combination, <code>manage/on</code> is used (<a href='#manage-syntax'>e.3.5</a>).</p></div><div class="code"><pre><code class="clojure">(manage (complex-operation)
        (on :node-working [node-name]
            (choose :wait-for-node))
        (on :node-failed [node-name]
            (choose :reinit-node))
        (on :database-down []
            (choose :use-database backup-database))
        (on :core-failed []
            (terminate-everything)))</code></pre></div><div><p>Issues are managed through <code>on</code> handlers within a <code>manage</code> block. If any <code>issue</code> is raised with the manage block, it is passed to each handler. There are six ways that a handler can deal with a raised issue:</p><ul><li>directly (same as <code>try/catch</code>)</li><li>using <code>continue</code> to keep going with a given value</li><li>using <code>choose</code> to specify an option</li><li>using <code>escalate</code> to notify higher level managers</li><li>using <code>default</code> to allow the issue to resolve itself</li><li>using <code>fail</code> to throw an exception</li></ul><p>Using these six different different issue resolution directives, the programmer has the richness of language to craft complex process control flow strategies without mixing logic handling code in the middle tier. Restarts can also create new ways of thinking about the problem beyond the standard <code>throw/catch</code> mechanism and offer more elegant ways to build programs and workflows.</p></div><div><span id="quickstart" name="quickstart"></span><h2><b>4 &nbsp;&nbsp; Quickstart</b></h2></div><div><span id="unlucky-numbers" name="unlucky-numbers"></span><h3>4.1 &nbsp;&nbsp; Unlucky Numbers</h3></div><div><p>In this demonstration, we look at how code bloat problems using <code>throw/try/catch</code> could be reduced using <code>raise/manage/on</code>. Two functions are defined:</p><ul><li><code>check-unlucky</code> which takes a number as input, throwing a <code>RuntimeException</code> when it sees an unlucky number.</li><li><code>int-to-str</code> which calls <code>check-unlucky</code>, pretends to do work and outputs a string represention of the number.</li></ul></div><div class="code"><pre><code class="clojure">(defn check-unlucky [n]
  (if (#{4 13 14 24 666} n)
    (throw (RuntimeException. &quot;Unlucky Number&quot;))
    n))

(defn int-to-str [n]
  (do (Thread/sleep 10)  ;; Work out something
      (str (check-unlucky n))))</code></pre></div><div class="code"><pre><code class="clojure">(int-to-str 1) =&gt; &quot;1&quot;

(int-to-str 666) =&gt; (throws RuntimeException &quot;Unlucky Number&quot;)</code></pre></div><div><p>We can then use <code>int-to-str</code> to run across multiple numbers:</p></div><div class="code"><pre><code class="clojure">(mapv int-to-str (range 4))
=&gt; [&quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot;]</code></pre></div><div><span id="getting-messy" name="getting-messy"></span><h3>4.2 &nbsp;&nbsp; Getting Messy</h3></div><div><p>Except when we try to use it in with a sequence containing an unlucky number</p></div><div class="code"><pre><code class="clojure">(mapv int-to-str (range 20))
=&gt; (throws RuntimeException &quot;Unlucky Number&quot;)</code></pre></div><div><p>We can try and recover using <code>try/catch</code></p></div><div class="code"><pre><code class="clojure">(try
  (mapv int-to-str (range 20))
  (catch RuntimeException e
    &quot;Unlucky number in the sequence&quot;))
=&gt; &quot;Unlucky number in the sequence&quot;</code></pre></div><div><p>But we can never get the previous sequence back again because we have blown the stack. The only way to 'fix' this problem is to change <code>int-to-str</code> so that it catches the exception:</p></div><div class="code"><pre><code class="clojure">(defn int-to-str-fix [n]
  (try
    (if (check-unlucky n)    ;;
      (do (Thread/sleep 10)  ;; Work out something
          (str n)))
    (catch RuntimeException e
      &quot;-&quot;)))

(mapv int-to-str-fix (range 20))
=&gt; [&quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;-&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot;
    &quot;11&quot; &quot;12&quot; &quot;-&quot; &quot;-&quot; &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot;]</code></pre></div><div><p>This is seriously unattractive code. We have doubled our line-count to <code>int-to-str</code> without adding too much functionality. For real world scenarios like batch processing a bunch of files, there are more ways that the program can go wrong. The middle code becomes messy very quickly.</p></div><div><span id="raise-dont-throw" name="raise-dont-throw"></span><h3>4.3 &nbsp;&nbsp; Raise, don't Throw</h3></div><div><p>This problem actually has a very elegant solution. Instead of throwing an exception, we can <code>raise</code> an issue in <code>check-unlucky</code>:</p></div><div class="code"><pre><code class="clojure">(defn check-unlucky [n]
  (if (#{4 13 14 24 666} n)
    (raise [:unlucky-number {:value n}])
    n))</code></pre></div><div><p><code>int-to-str</code> does not have to change</p></div><div class="code"><pre><code class="clojure">(defn int-to-str [n]
  (do (Thread/sleep 10)  ;; Work out something
      (str (check-unlucky n))))</code></pre></div><div><p>We still get the same functionality:</p></div><div class="code"><pre><code class="clojure">(int-to-str 1) =&gt; &quot;1&quot;

(mapv int-to-str (range 4))
=&gt; [&quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot;]</code></pre></div><div><span id="issues-and-abnormal-flow" name="issues-and-abnormal-flow"></span><h3>4.4 &nbsp;&nbsp; Issues and Abnormal Flow</h3></div><div><p>What happens when we use this with unlucky numbers? Its almost the same... except that instead of raising a <code>RuntimeException</code>, we get a <code>clojure.lang.ExceptionInfo</code> object:</p></div><div class="code"><pre><code class="clojure">(mapv int-to-str (range 20))
=&gt; (throws clojure.lang.ExceptionInfo)</code></pre></div><div><p>We can still use <code>try/catch</code> to recover from the error</p></div><div class="code"><pre><code class="clojure">(try
  (mapv int-to-str (range 20))
  (catch clojure.lang.ExceptionInfo e
    &quot;Unlucky number in the sequence&quot;))
=&gt; &quot;Unlucky number in the sequence&quot;</code></pre></div><div><p>We set up the handlers by replacing <code>try</code> with <code>manage</code> and <code>catch</code> with <code>on</code>. This gives the exact same result as before.</p></div><div class="code"><pre><code class="clojure">(manage
  (mapv int-to-str (range 20))
  (on :unlucky-number []
    &quot;Unlucky number in the sequence&quot;))
=&gt; &quot;Unlucky number in the sequence&quot;</code></pre></div><div><span id="a-sleight-of-hand" name="a-sleight-of-hand"></span><h3>4.5 &nbsp;&nbsp; A Sleight of Hand</h3></div><div><p>However, the whole point of this example is that we wish to keep the previous results without ever changing <code>int-to-str</code>. We will do this with <code>continue</code>:</p></div><div class="code"><pre><code class="clojure">(manage
  (mapv int-to-str (range 20))
  (on :unlucky-number []
      (continue &quot;-&quot;)))
=&gt; [&quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;-&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot;
    &quot;11&quot; &quot;12&quot; &quot;-&quot; &quot;-&quot; &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot;]</code></pre></div><div><p>So what just happened?</p><p><code>continue</code> is a special form that allows higher level functions to jump back into the place where the exception was called. So once the manage block was notified of the issue raised in <code>check-unlucky</code>, it did not blow away the stack but jumped back to the back at which the issue was raised and continued on with <code>-</code> instead. In this way, the exception handling code instead of being written in <code>int-to-str</code>, can now be written at the level that it is required.</p></div><div><span id="chinese-unlucky-numbers" name="chinese-unlucky-numbers"></span><h3>4.6 &nbsp;&nbsp; Chinese Unlucky Numbers</h3></div><div><p>The chinese don't like the number 4 and any number with the number 4, but they don't mind 13 and 666. We can write use the <code>on</code> handler to define cases to process:</p></div><div class="code"><pre><code class="clojure">(defn ints-to-strs-chinese [arr]
  (manage
   (mapv int-to-str arr)
   (on {:unlucky-number true
        :value #(or (= % 666)
                    (= % 13))}
       [value]
       (continue value))

   (on :unlucky-number []
       (continue &quot;-&quot;))))

(ints-to-strs-chinese [11 12 13 14])
=&gt; [&quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;-&quot;]

(ints-to-strs-chinese [1 2 666])
=&gt; [&quot;1&quot; &quot;2&quot; &quot;666&quot;]</code></pre></div><div><span id="christian-unlucky-numbers" name="christian-unlucky-numbers"></span><h3>4.7 &nbsp;&nbsp; Christian Unlucky Numbers</h3></div><div><p>The christians don't mind numbers with 4, don't like 13 and really don't like 666. In this example, it can be seen that if 666 is seen, it will jump out and return straight away, but will continue on processing with other numbers.</p></div><div class="code"><pre><code class="clojure">(defn ints-to-strs-christian [arr]
  (manage
   (mapv int-to-str arr)
   (on [:unlucky-number] [value]
       (condp = value
         13 (continue &quot;-&quot;)
         666 &quot;ARRRGHHH!&quot;
         (continue value)))))

(ints-to-strs-christian [11 12 13 14])
=&gt; [&quot;11&quot; &quot;12&quot; &quot;-&quot; &quot;14&quot;]

(ints-to-strs-christian [1 2 666])
=&gt; &quot;ARRRGHHH!&quot;</code></pre></div><div><p>It can be seen from this example that the <code>int-to-str</code> function can be reused without any changes. this would be extremely difficult to do with just <code>try/catch</code>.</p><p>For the still sceptical, I'm proposing a <strong>challenge</strong>: to reimplement <code>ints-to-strs-christian</code> without changing <code>unlucky-numbers</code> or <code>int-to-str</code> using only <code>try</code> and <code>catch</code>.</p></div><div><span id="guides" name="guides"></span><h2><b>5 &nbsp;&nbsp; Guides</b></h2></div><div><span id="api-raise" name="api-raise"></span><h3>5.1 &nbsp;&nbsp; raise</h3></div><div><p>The keyword <code>raise</code> is used to raise an 'issue'. At the simplest, when there is no <code>manage</code> blocks, <code>raise</code> just throws a <code>clojure.lang.ExceptionInfo</code> object</p></div><div class="code"><pre><code class="clojure">[[{:title &quot;raise is of type clojure.lang.ExceptionInfo&quot; :tag &quot;raise-type&quot;}]]
(raise {:error true})
=&gt; (throws clojure.lang.ExceptionInfo)</code></pre></div><div><p>The payload of the issue can be extracted using <code>ex-data</code></p></div><div class="code"><pre><code class="clojure">(try
  (raise {:error true})
  (catch clojure.lang.ExceptionInfo e
    (ex-data e)))
=&gt; {:error true}</code></pre></div><div><p>The payload can be expressed as a <code>hash-map</code>, a <code>keyword</code> or a <code>vector</code>. We can to define the <code>payload</code> macro:</p></div><div class="code"><pre><code class="clojure">(defmacro payload [&amp; body]
    `(try ~@body
          (throw (Throwable.))
          (catch clojure.lang.ExceptionInfo e#
            (ex-data e#))
          (catch Throwable t#
            (throw (Exception. &quot;No Issue raised&quot;)))))</code></pre></div><div><p>Its can be used to detect what type of issue has been raised:</p></div><div class="code"><pre><code class="clojure">(payload (raise :error))
=&gt; {:error true}</code></pre></div><div><span id="hash-map" name="hash-map"></span><h3><i>5.1.1 &nbsp;&nbsp; hash-map</i></h3></div><div><p>Because the issue can be expressed as a hash-map, it is more general than using a class to represent exceptions.</p></div><div class="code"><pre><code class="clojure">(raise {:error true :data &quot;data&quot;})
=&gt; (throws-info {:error true :data &quot;data&quot;})</code></pre></div><div><span id="keyword" name="keyword"></span><h3><i>5.1.2 &nbsp;&nbsp; keyword</i></h3></div><div><p>When a <code>keyword</code> is used, it is shorthand for a map with having the specified keyword with value <code>true</code>.</p></div><div class="code"><pre><code class="clojure">(raise :error)
=&gt; (throws-info {:error true})</code></pre></div><div><span id="vector" name="vector"></span><h3><i>5.1.3 &nbsp;&nbsp; vector</i></h3></div><div><p>Vectors can contain only keywords or both maps and keywords. They are there mainly for syntacic sugar</p></div><div class="code"><pre><code class="clojure">(raise [:lvl-1 :lvl-2 :lvl-3])
=&gt; (throws-info {:lvl-1 true :lvl-2 true :lvl-3 true})


(raise [:lvl-1 {:lvl-2 true :data &quot;data&quot;}])
 =&gt; (throws-info {:lvl-1 true :lvl-2 true :data &quot;data&quot;})</code></pre></div><div><span id="option--default" name="option--default"></span><h3>5.2 &nbsp;&nbsp; option/default</h3></div><div><p>Strategies for an unmanaged issue can be specified within the raise form:</p><ul><li><a href='#option-one'>e.</a> specifies two options and the specifies the default option as <code>:use-nil</code>.</li><li><a href='#option-two'>e.</a> sets the default as <code>:use-custom</code> with an argument of <code>10</code>.</li><li><a href='#option-none'>e.</a> shows that if there is no default selection, then an exception will be thrown as per previously seen:</li></ul></div><div class="code"><pre><code class="clojure">[[{:title &quot;default :use-nil&quot; :tag &quot;option-one&quot;}]]
(raise :error
       (option :use-nil [] nil)
       (option :use-custom [n] n)
       (default :use-nil))
=&gt; nil

[[{:title &quot;default :use-custom&quot; :tag &quot;option-two&quot;}]]
(raise :error
       (option :use-nil [] nil)
       (option :use-custom [n] n)
       (default :use-custom 10))
=&gt; 10

[[{:title &quot;no default&quot; :tag &quot;option-none&quot;}]]
(raise :error
       (option :use-nil [] nil)
       (option :use-custom [n] n))
=&gt; (throws-info {:error true})</code></pre></div><div><span id="manage--on" name="manage--on"></span><h3>5.3 &nbsp;&nbsp; manage/on</h3></div><div><p>Raised issues can be resolved through use of <code>manage</code> blocks set up. The blocks set up execution scope, providing handlers and options to redirect program flow. A manage block looks like this:</p></div><div class="code"><pre><code class="clojure">(manage

 ... code that may raise issue ...

 (on &lt;chk&gt; &lt;bindings&gt;
     ... handler body ...)

 (option &lt;label&gt; &lt;bindings&gt;
     ... option body ...)

 (finally                   ;; only one
     ... finally body ...))</code></pre></div><div><p>We define <code>half-int</code> and its usage:</p></div><div class="code"><pre><code class="clojure">(defn half-int [n]
  (if (= 0 (mod n 2))
    (quot n 2)
    (raise [:odd-number {:value n}])))</code></pre></div><div class="code"><pre><code class="clojure">(half-int 2)
=&gt; 1

(half-int 3)
=&gt; (throws-info {:odd-number true :value 3})</code></pre></div><div><span id="checkers" name="checkers"></span><h3>5.4 &nbsp;&nbsp; checkers</h3></div><div><p>Within the <code>manage</code> form, issue handlers are specified with <code>on</code>. The form requires a check, which if returns true will be activated:</p></div><div class="code"><pre><code class="clojure">(manage
 (mapv half-int [1 2 3 4])
 (on :odd-number []
     &quot;odd-number-exception&quot;))
=&gt; &quot;odd-number-exception&quot;</code></pre></div><div><p>The checker can be a map with the value</p></div><div class="code"><pre><code class="clojure">(manage
 (mapv half-int [1 2 3 4])
 (on {:odd-number true} []
     &quot;odd-number-exception&quot;))
=&gt; &quot;odd-number-exception&quot;</code></pre></div><div><p>Or it can be a map with a checking function:</p></div><div class="code"><pre><code class="clojure">(manage
 (mapv half-int [1 2 3 4])
 (on {:odd-number true?} []
     &quot;odd-number-exception&quot;))
=&gt; &quot;odd-number-exception&quot;</code></pre></div><div><p>A set will check if any elements are true</p></div><div class="code"><pre><code class="clojure">(manage
 (mapv half-int [1 2 3 4])
 (on #{:odd-number} []
     &quot;odd-number-exception&quot;))
=&gt; &quot;odd-number-exception&quot;</code></pre></div><div><p>A vector will check if all elements are true </p></div><div class="code"><pre><code class="clojure">(manage
 (mapv half-int [1 2 3 4])
 (on [:odd-number] []
     &quot;odd-number-exception&quot;))
=&gt; &quot;odd-number-exception&quot;</code></pre></div><div><p>An underscore will match anything</p></div><div class="code"><pre><code class="clojure">(manage
 (mapv half-int [1 2 3 4])
 (on _ []
     &quot;odd-number-exception&quot;))
=&gt; &quot;odd-number-exception&quot;</code></pre></div><div><p><code>on-any</code> can also be used instead of <code>on &#95;</code></p></div><div class="code"><pre><code class="clojure">(manage
 (mapv half-int [1 2 3 4])
 (on-any []
     &quot;odd-number-exception&quot;))
=&gt; &quot;odd-number-exception&quot;</code></pre></div><div><span id="bindings" name="bindings"></span><h3>5.5 &nbsp;&nbsp; bindings</h3></div><div><p>Bindings within the <code>on</code> handler allow values in the issue payload to be accessed:</p></div><div class="code"><pre><code class="clojure">(manage
 (mapv half-int [1 2 3 4])
 (on :odd-number e
     (str &quot;odd-number: &quot; (:odd-number e) &quot;, value: &quot; (:value e))))
=&gt; &quot;odd-number: true, value: 1&quot;</code></pre></div><div><p>Bindings can be a vector</p></div><div class="code"><pre><code class="clojure">(manage
 (mapv half-int [1 2 3 4])
 (on :odd-number [odd-number value]
     (str &quot;odd-number: &quot; odd-number &quot;, value: &quot; value)))
=&gt; &quot;odd-number: true, value: 1&quot;</code></pre></div><div><p>Bindings can also be a hashmap</p></div><div class="code"><pre><code class="clojure">(manage
 (mapv half-int [1 2 3 4])
 (on :odd-number {odd? :odd-number v :value}
     (str &quot;odd-number: &quot; odd? &quot;, value: &quot; v)))
=&gt; &quot;odd-number: true, value: 1&quot;</code></pre></div><div><span id="catch-and-finally" name="catch-and-finally"></span><h3>5.6 &nbsp;&nbsp; catch and finally</h3></div><div><p>The special forms <code>catch</code> and <code>finally</code> are also supported in the <code>manage</code> blocks for exception handling just as they are in <code>try</code> blocks.</p></div><div class="code"><pre><code class="clojure">(manage
 (throw (Exception. &quot;Hello&quot;))
 (catch Exception e
   &quot;odd-number-exception&quot;)
 (finally
   (println &quot;Hello&quot;)))
=&gt; &quot;odd-number-exception&quot; ;; Also prints &quot;Hello&quot;</code></pre></div><div><p>They can be mixed and matched with <code>on</code> forms</p></div><div class="code"><pre><code class="clojure">(manage
 (mapv half-int [1 2 3 4])
 (on :odd-number []
     &quot;odd-number-exception&quot;)
 (finally
   (println &quot;Hello&quot;)))
=&gt; &quot;odd-number-exception&quot; ;; Also prints &quot;Hello&quot;</code></pre></div><div><span id="special-forms" name="special-forms"></span><h3>5.7 &nbsp;&nbsp; special forms</h3></div><div><p>There are five special forms that can be used within the <code>on</code> handler:</p><ul><li><a href='#api-continue'>continue</a></li><li><a href='#api-fail'>fail</a></li><li><a href='#api-choose'>choose</a></li><li><a href='#api-default'>default</a></li><li><a href='#api-escalate'>escalate</a></li></ul></div><div><span id="api-continue" name="api-continue"></span><h3>5.8 &nbsp;&nbsp; continue</h3></div><div><p>The <code>continue</code> special form is used to continue the operation from the point that the <code>issue</code> was raised (<a href='#continue-using-nan'>e.</a>). It must be pointed out that this is impossible to do using the <code>try/catch</code> paradigm because the all the information from the stack will be lost.</p><p>  The <code>on</code> handler can take keys of the <code>payload</code> of the raised <code>issue</code> as parameters. In <a href='#continue-using-str'>e.</a>, a vector containing strings of the odd numbers are formed. Whereas in <a href='#continue-using-fractions'>e.</a>, the on handler puts in fractions instead.</p></div><div class="code"><pre><code class="clojure">[[{:title &quot;continue using nan&quot;}]]
(manage
 (mapv half-int [1 2 3 4])
 (on :odd-number []
     (continue :nan)))
=&gt; [:nan 1 :nan 2]

[[{:title &quot;continue using str&quot;}]]
(manage
 (mapv half-int [1 2 3 4])
 (on :odd-number [value]
     (continue (str value))))
=&gt; [&quot;1&quot; 1 &quot;3&quot; 2]

[[{:title &quot;continue using fractions&quot;}]]
(manage
 (mapv half-int [1 2 3 4])
 (on :odd-number [value]
     (continue (/ value 2))))
=&gt; [1/2 1 3/2 2]</code></pre></div><div><span id="api-fail" name="api-fail"></span><h3>5.9 &nbsp;&nbsp; fail</h3></div><div><p>The <code>fail</code> special form will forcibly cause an exception to be thrown. It is used when there is no need to advise managers of situation. More data can be added to the failure (<a href='#fail-example'>e.</a>).</p></div><div class="code"><pre><code class="clojure">[[{:title &quot;failure&quot;}]]
(manage
  (mapv half-int [1 2 3 4])
  (on :odd-number []
    (fail [:unhandled :error])))
=&gt; (throws-info {:value 1 :odd-number true :unhandled true :error true})</code></pre></div><div><span id="api-choose" name="api-choose"></span><h3>5.10 &nbsp;&nbsp; choose</h3></div><div><p>The <code>choose</code> special form is used to jump to a <code>option</code>. A new function <code>half-int-b</code> (<a href='#half-int-b-definition'>e.</a>) is defined giving options to jump to within the <code>raise</code> form.</p></div><div class="code"><pre><code class="clojure">(defn half-int-b [n]
    (if (= 0 (mod n 2))
      (quot n 2)
      (raise [:odd-number {:value n}]
             (option :use-nil [] nil)
             (option :use-nan [] :nan)
             (option :use-custom [n] n))))</code></pre></div><div><p>Its usage can be seen in <a href='#choose-ex-1'>e.</a> where different paths can be chosen depending upon <code>:value</code>. An option can also be specified in the manage block (<a href='#choose-ex-2'>e.</a>). Options can also be overridden when specified in higher manage blocks (<a href='#choose-ex-3'>e.</a>). </p></div><div class="code"><pre><code class="clojure">[[{:title &quot;choosing different paths based on value&quot; :tag &quot;choose-ex-1&quot;}]]
(manage
 (mapv half-int-b [1 2 3 4])
 (on {:value 1} []
     (choose :use-nil))
 (on {:value 3} [value]
     (choose :use-custom (/ value 2))))
=&gt; [nil 1 3/2 2]


[[{:title &quot;choosing option within manage form&quot; :tag &quot;choose-ex-2&quot;}]]
(manage
 (mapv half-int-b [1 2 3 4])
 (on :odd-number []
     (choose :use-empty))
 (option :use-empty [] []))
=&gt; []

[[{:title &quot;overwriting :use-nil within manage form&quot; :tag &quot;choose-ex-3&quot;}]]
(manage
 (mapv half-int-b [1 2 3 4])
 (on :odd-number []
     (choose :use-nil))
 (option :use-nil [] nil))
=&gt; nil</code></pre></div><div><span id="api-default" name="api-default"></span><h3>5.11 &nbsp;&nbsp; default</h3></div><div><p> The <code>default</code> special short-circuits the raise process and skips managers further up to use an issue's default option. A function is defined and is usage is shown how the <code>default</code> form behaves. </p></div><div class="code"><pre><code class="clojure">(defn half-int-c [n]
  (if (= 0 (mod n 2))
    (quot n 2)
    (raise [:odd-number {:value n}]
           (option :use-nil [] nil)
           (option :use-custom [n] n)
           (default :use-custom :odd))))

(manage
 (mapv half-int-c [1 2 3 4])
 (on :odd-number [value] (default)))
=&gt; [:odd 1 :odd 2]</code></pre></div><div><p>The <code>default</code> form can even refer to an option that has to be implemented higher up in scope. An additional function is defined: </p></div><div class="code"><pre><code class="clojure">(defn half-int-d [n]
  (if (= 0 (mod n 2))
    (quot n 2)
    (raise [:odd-number {:value n}]
           (default :use-empty))))</code></pre></div><div><p>The usage for <code>half-int-d</code> can be seen in (<a href='#d-alone'>e.</a> and <a href='#d-higher'>e.</a>) to show these particular cases.</p></div><div class="code"><pre><code class="clojure">[[{:title &quot;half-int-d alone&quot; :tag &quot;d-alone&quot;}]]
(half-int-d 3)
=&gt; (throws java.lang.Exception &quot;RAISE_CHOOSE: the label :use-empty has not been implemented&quot;)

[[{:title &quot;half-int-d inside manage block&quot; :tag &quot;d-higher&quot;}]]
(manage
 (mapv half-int-d [1 2 3 4])
 (option :use-empty [] [])
 (on :odd-number []
     (default)))
=&gt; []</code></pre></div><div><span id="api-escalate" name="api-escalate"></span><h3>5.12 &nbsp;&nbsp; escalate</h3></div><div><p>The <code>escalate</code> special form is used to add additional information to the issue and raised to higher managers. In the following example, if a <code>3</code> or a <code>5</code> is seen, then the flag <code>:three-or-five</code> is added to the issue and the <code>:odd-number</code> flag is set false.</p></div><div class="code"><pre><code class="clojure">(defn half-array-e [arr]
  (manage
    (mapv half-int-d arr)
    (on {:value (fn [v] (#{3 5} v))} [value]
        (escalate [:three-or-five {:odd-number false}]))))

(manage
  (half-array-e [1 2 3 4 5])
  (on :odd-number [value]
      (continue (* value 10)))
  (on :three-or-five [value]
      (continue (* value 100))))
  =&gt; [10 1 300 2 500]</code></pre></div><div><p>Program decision points can be changed by higher level managers through <code>escalate</code></p></div><div class="code"><pre><code class="clojure">(defn half-int-f [n]
 (manage
   (if (= 0 (mod n 2))
     (quot n 2)
     (raise [:odd-number {:value n}]
       (option :use-nil [] nil)
       (option :use-custom [n] n)
       (default :use-nil)))

    (on :odd-number []
      (escalate :odd-number
        (option :use-zero [] 0)
        (default :use-custom :nan)))))

(half-int-f 3) =&gt; :nan  ;; (instead of nil)
(mapv half-int-f [1 2 3 4])

=&gt; [:nan 1 :nan 2] ;; notice that the default is overridden

(manage
  (mapv half-int-f [1 2 3 4])
  (on :odd-number []
    (choose :use-zero)))

=&gt; [0 1 0 2]   ;; using an escalated option</code></pre></div><div><p>Options specified higher up are favored:</p></div><div class="code"><pre><code class="clojure">(manage
  (mapv half-int-f [1 2 3 4])
  (on :odd-number []
    (choose :use-nil)))

  =&gt; [nil 1 nil 2]

  (manage
   (mapv half-int-f [1 2 3 4])
   (on :odd-number []
     (choose :use-nil))
   (option :use-nil [] nil))

  =&gt; nil  ;; notice that the :use-nil is overridden</code></pre></div><div><span id="strategies" name="strategies"></span><h2><b>6 &nbsp;&nbsp; Strategies</b></h2></div><div><p>This is a comprehensive (though non-exhaustive) list of program control strategies that can be used. It can be noted that the <code>try/catch</code> paradigm can implement sections <a href='#normal'>6.1</a> and <a href='#catch'>6.2</a>. Other clojure restart libraries such as <code>errorkit</code>, <code>swell</code> and <code>conditions</code> additionally implement sections <a href='#continue'>6.3</a>, <a href='#choose'>6.4</a> and <a href='#choose-more'>6.5</a>.</p><p><code>hara.event</code> supports novel (and more natural) program control mechanics through the <code>escalate</code> (<a href='#escalate'>6.6</a>), <code>fail</code> (<a href='#fail'>6.7</a>) and  <code>default</code> (<a href='#default'>6.8</a>) special forms as well as branching support in the <code>on</code> special form (<a href='#on-form'>6.9</a>).</p></div><div><span id="normal" name="normal"></span><h3>6.1 &nbsp;&nbsp; Normal</h3></div><div><span id="no-raise" name="no-raise"></span><h3><i>6.1.1 &nbsp;&nbsp; No Raise</i></h3></div><div><p>The most straightforward code is one where no issues raised:</p></div><div class="code"><a id="event-normal-eq" name="event-normal-eq"></a><pre><code class="clojure">(manage            ;; L2
 [1 2 (manage 3)]) ;; L1 and L0

=&gt; [1 2 3]</code></pre></div><div class="figure"><a id="no-issues-flow" name="no-issues-flow"></a><h4><i>fig.2  &nbsp;-&nbsp; No Issues Flow</i></h4><div class="img"><img height="300px" line="{:row 21, :col 1, :end-row 21, :end-col 91}" src="img/hara_event/norm_normal.png" title="No Issues Flow" /></div><p></p></div><div><span id="issue-raised" name="issue-raised"></span><h3><i>6.1.2 &nbsp;&nbsp; Issue Raised</i></h3></div><div><p>If there is an issue raised with no handler, it will <code>throw</code> an exception.</p></div><div class="code"><pre><code class="clojure">(manage                  ;; L2
 [1 2 (manage            ;; L1
       (raise {:A true}))]) ;; L0
  
=&gt; (throws-info {:A true})</code></pre></div><div class="figure"><a id="unmanaged-issue-flow" name="unmanaged-issue-flow"></a><h4><i>fig.3  &nbsp;-&nbsp; Unmanaged Issue Flow</i></h4><div class="img"><img height="300px" line="{:row 35, :col 1, :end-row 35, :end-col 100}" src="img/hara_event/norm_unmanaged.png" title="Unmanaged Issue Flow" /></div><p></p></div><div><span id="catch" name="catch"></span><h3>6.2 &nbsp;&nbsp; Catch</h3></div><div><p>Once an issue has been raised, it can be handled within a managed scope through the use of 'on'. 'manage/on' is the equivalent to 'try/catch' in the following two cases:</p></div><div><span id="first-level-catch" name="first-level-catch"></span><h3><i>6.2.1 &nbsp;&nbsp; First Level Catch</i></h3></div><div class="code"><pre><code class="clojure">(manage                          ;; L2
 [1 2 (manage                    ;; L1
       (raise :A)                ;; L0
       (on :A [] :A))]           ;; H1A
 (on :B [] :B))                  ;; H2B

=&gt; [1 2 :A]</code></pre></div><div class="figure"><a id="catch-on-a-flow" name="catch-on-a-flow"></a><h4><i>fig.4  &nbsp;-&nbsp; Catch on :A Flow</i></h4><div class="img"><img height="300px" line="{:row 54, :col 1, :end-row 54, :end-col 94}" src="img/hara_event/catch_flow_a.png" title="Catch on :A Flow" /></div><p></p></div><div><span id="second-level-catch" name="second-level-catch"></span><h3><i>6.2.2 &nbsp;&nbsp; Second Level Catch</i></h3></div><div class="code"><pre><code class="clojure">(manage                          ;; L2
 [1 2 (manage                    ;; L1
       (raise :B)                ;; L0
       (on :A [] :A))]           ;; H1A
 (on :B [] :B))                  ;; H2B

=&gt; :B</code></pre></div><div class="figure"><a id="catch-on-b-flow" name="catch-on-b-flow"></a><h4><i>fig.5  &nbsp;-&nbsp; Catch on :B Flow</i></h4><div class="img"><img height="300px" line="{:row 67, :col 1, :end-row 67, :end-col 94}" src="img/hara_event/catch_flow_b.png" title="Catch on :B Flow" /></div><p></p></div><div><span id="continue" name="continue"></span><h3>6.3 &nbsp;&nbsp; Continue</h3></div><div><p>The 'continue' form signals that the program  should resume at the point that the issue  was raised.</p></div><div><span id="first-level-continue" name="first-level-continue"></span><h3><i>6.3.1 &nbsp;&nbsp; First Level Continue</i></h3></div><div><p>In the first case, this gives the same result as <code>try/catch</code>.</p></div><div class="code"><pre><code class="clojure">(manage                          ;; L2
 [1 2 (manage                    ;; L1
       (raise :A)                ;; L0
       (on :A []                 ;; H1A
           (continue :3A)))]
 (on :B []                       ;; H2B
     (continue :3B)))
=&gt; [1 2 :3A]</code></pre></div><div class="figure"><a id="continue-on-a-flow" name="continue-on-a-flow"></a><h4><i>fig.6  &nbsp;-&nbsp; Continue on :A Flow</i></h4><div class="img"><img height="300px" line="{:row 87, :col 1, :end-row 87, :end-col 100}" src="img/hara_event/continue_flow_a.png" title="Continue on :A Flow" /></div><p></p></div><div><span id="second-level-continue" name="second-level-continue"></span><h3><i>6.3.2 &nbsp;&nbsp; Second Level Continue</i></h3></div><div><p>However, it can be seen that when 'continue' is used    on the outer manage blocks, it provides the 'manage/on'    a way for top tier forms to affect the bottom tier forms    without manipulating logic in the middle tier</p></div><div class="code"><pre><code class="clojure">(manage                          ;; L2
 [1 2 (manage                    ;; L1
       (raise :B)                ;; L0
       (on :A []                 ;; H1A
           (continue :3A)))]
 (on :B []                       ;; H2B
     (continue :3B)))
=&gt; [1 2 :3B]</code></pre></div><div class="figure"><a id="continue-on-b-flow" name="continue-on-b-flow"></a><h4><i>fig.7  &nbsp;-&nbsp; Continue on :B Flow</i></h4><div class="img"><img height="300px" line="{:row 107, :col 1, :end-row 107, :end-col 100}" src="img/hara_event/continue_flow_b.png" title="Continue on :B Flow" /></div><p></p></div><div><span id="choose" name="choose"></span><h3>6.4 &nbsp;&nbsp; Choose</h3></div><div><p><code>choose</code> and <code>option</code> work together within manage scopes. A raised issue can have options attached to it, just a worker might give their manager certain options to choose from when an unexpected issue arises. Options can be chosen that lie anywhere within the manage blocks.</p></div><div><span id="choose-lower-level" name="choose-lower-level"></span><h3><i>6.4.1 &nbsp;&nbsp; Choose Lower-Level</i></h3></div><div class="code"><pre><code class="clojure">(manage                        ;; L2
 [1 2 (manage                  ;; L1
       (raise :A               ;; L0
              (option :X [] :3X)) ;; X
       (on :A []                  ;; H1A
           (choose :X))
       (option :Y [] :3Y))] ;; Y
 (option :Z [] :3Z))        ;; Z

=&gt; [1 2 :3X]</code></pre></div><div class="figure"><a id="choose-x-flow" name="choose-x-flow"></a><h4><i>fig.8  &nbsp;-&nbsp; Choose :X Flow</i></h4><div class="img"><img height="300px" line="{:row 130, :col 1, :end-row 130, :end-col 93}" src="img/hara_event/choose_flow_x.png" title="Choose :X Flow" /></div><p></p></div><div><p>However in some cases, upper level options can be accessed as in this case. This can be used to set global strategies to deal with very issues that have serious consequences if it was to go ahead.</p><p>   An example maybe a mine worker who finds a gas-leak. Because of previously conveyed instructions, he doesn't need to inform his manager and shuts down the plant immediately.</p></div><div><span id="choose-upper-level" name="choose-upper-level"></span><h3><i>6.4.2 &nbsp;&nbsp; Choose Upper-Level</i></h3></div><div class="code"><pre><code class="clojure">(manage                           ;; L2
 [1 2 (manage                     ;; L1
       (raise :A                  ;; L0
              (option :X [] :3X)) ;; X
       (on :A []                  ;; H1A
           (choose :Z))
       (option :Y [] :3Y))]       ;; Y
 (option :Z [] :3Z))              ;; Z
=&gt; :3Z</code></pre></div><div class="figure"><a id="choose-z-flow" name="choose-z-flow"></a><h4><i>fig.9  &nbsp;-&nbsp; Choose :Z Flow</i></h4><div class="img"><img height="300px" line="{:row 151, :col 1, :end-row 151, :end-col 93}" src="img/hara_event/choose_flow_z.png" title="Choose :Z Flow" /></div><p></p></div><div><span id="choose-more" name="choose-more"></span><h3>6.5 &nbsp;&nbsp; Choose - More Strategies</h3></div><div><span id="overridding-an-option" name="overridding-an-option"></span><h3><i>6.5.1 &nbsp;&nbsp; Overridding An Option</i></h3></div><div><p>If there are two options with the same label,   choose will take the option specified at the highest   management level. This means that managers at higher   levels can over-ride lower level strategies.</p></div><div class="code"><pre><code class="clojure">(manage                            ;; L2
 [1 2 (manage                      ;; L1
       (raise :A                   ;; L0
              (option :X [] :3X0)) ;; X0 - This is ignored
       (on :A []                   ;; H1A
           (choose :X))
       (option :X [] :3X1))]       ;; X1 - This is chosen
 (option :Z [] :3Z))               ;; Z

=&gt; [1 2 :3X1]</code></pre></div><div class="figure"><a id="choose-x1-flow" name="choose-x1-flow"></a><h4><i>fig.10  &nbsp;-&nbsp; Choose :X1 Flow</i></h4><div class="img"><img height="300px" line="{:row 175, :col 1, :end-row 175, :end-col 95}" src="img/hara_event/choose_flow_x1.png" title="Choose :X1 Flow" /></div><p></p></div><div><span id="default-option" name="default-option"></span><h3><i>6.5.2 &nbsp;&nbsp; Default Option</i></h3></div><div><p>Specifying a 'default' option allows the raiser to    have autonomous control of the situation if the issue    remains unhandled.</p></div><div class="code"><pre><code class="clojure">(manage                            ;; L2
 [1 2 (manage                      ;; L1
       (raise :A                   ;; L0
              (default :X)         ;; D
              (option :X [] :3X))  ;; X
       (option :Y [] :3Y))]        ;; Y
 (option :Z [] :3Z))               ;; Z

=&gt; [1 2 :3X]</code></pre></div><div class="figure"><a id="choose-default-flow" name="choose-default-flow"></a><h4><i>fig.11  &nbsp;-&nbsp; Choose Default Flow</i></h4><div class="img"><img height="300px" line="{:row 193, :col 1, :end-row 193, :end-col 101}" src="img/hara_event/choose_default_x.png" title="Choose Default Flow" /></div><p></p></div><div><span id="overriding-defaults" name="overriding-defaults"></span><h3><i>6.5.3 &nbsp;&nbsp; Overriding Defaults</i></h3></div><div><p>This is an example of higher-tier managers overriding options</p></div><div class="code"><pre><code class="clojure">(manage                            ;; L2
 [1 2 (manage                      ;; L1
       (raise :A                   ;; L0
              (default :X)         ;; D
              (option :X [] :3X0)) ;; X0
       (option :X [] :3X1))]       ;; X1
 (option :X [] :3X2))             ;; X2

=&gt; :3X2</code></pre></div><div class="figure"><a id="choose-default-x2-flow" name="choose-default-x2-flow"></a><h4><i>fig.12  &nbsp;-&nbsp; Choose Default :X2 Flow</i></h4><div class="img"><img height="300px" line="{:row 211, :col 1, :end-row 211, :end-col 106}" src="img/hara_event/choose_default_x2.png" title="Choose Default :X2 Flow" /></div><p></p></div><div><span id="escalate" name="escalate"></span><h3>6.6 &nbsp;&nbsp; Escalate</h3></div><div><span id="simple-escalation" name="simple-escalation"></span><h3><i>6.6.1 &nbsp;&nbsp; Simple Escalation</i></h3></div><div><p>When issues are escalated, more information  can be added and this then is passed on to higher-tier managers</p></div><div class="code"><pre><code class="clojure">(manage                            ;; L2
 [1 2 (manage                      ;; L1
       (raise :A)                  ;; L0
       (on :A []                   ;; H1A
           (escalate :B)))]
 (on :B []                         ;; H2B
     (continue :3B)))
=&gt; [1 2 :3B]</code></pre></div><div class="figure"><a id="escalate-b-flow" name="escalate-b-flow"></a><h4><i>fig.13  &nbsp;-&nbsp; Escalate :B Flow</i></h4><div class="img"><img height="300px" line="{:row 233, :col 1, :end-row 233, :end-col 95}" src="img/hara_event/escalate_norm.png" title="Escalate :B Flow" /></div><p></p></div><div><span id="escalation-with-options" name="escalation-with-options"></span><h3><i>6.6.2 &nbsp;&nbsp; Escalation with Options</i></h3></div><div><p>More options can be added to escalate. When these options are chosen, it will continue at the point in which the issue was raised.</p></div><div class="code"><pre><code class="clojure">(manage                            ;; L2
 [1 2 (manage                      ;; L1
       (raise :A)                  ;; L0
       (on :A []                   ;; H1A
           (escalate
            :B
            (option :X [] :3X))))] ;; X
 (on :B []                        ;; H2B
     (choose :X)))
=&gt; [1 2 :3X]</code></pre></div><div class="figure"><a id="escalate-b-choose-x-flow" name="escalate-b-choose-x-flow"></a><h4><i>fig.14  &nbsp;-&nbsp; Escalate :B, Choose :X Flow</i></h4><div class="img"><img height="300px" line="{:row 250, :col 1, :end-row 250, :end-col 109}" src="img/hara_event/escalate_options.png" title="Escalate :B, Choose :X Flow" /></div><p></p></div><div><span id="fail" name="fail"></span><h3>6.7 &nbsp;&nbsp; Fail</h3></div><div><p>Fail forces a failure. It is used where there is already a default option and the manager really needs it to fail.</p></div><div class="code"><pre><code class="clojure">(manage                          ;; L2
 [1 2 (manage                    ;; L1
       (raise :A                 ;; L0
              (option :X [] :X)
              (default :X))
       (on :A []                 ;; H1A
           (fail :B)))])
=&gt; (throws-info {:A true :B true})</code></pre></div><div class="figure"><a id="force-fail-flow" name="force-fail-flow"></a><h4><i>fig.15  &nbsp;-&nbsp; Force Fail Flow</i></h4><div class="img"><img height="300px" line="{:row 266, :col 1, :end-row 266, :end-col 85}" src="img/hara_event/fail.png" title="Force Fail Flow" /></div><p></p></div><div><span id="default" name="default"></span><h3>6.8 &nbsp;&nbsp; Default</h3></div><div><p>Default short-circuits higher managers so that the issue is resolved internally.</p></div><div class="code"><pre><code class="clojure">(manage                          ;; L2
 [1 2 (manage                    ;; L1
       (raise :A                 ;; L0
              (option :X [] :X)
              (default :X))
       (on :A []                  ;; H1A
           (default)))]
 (on :A [] (continue 3)))
=&gt; [1 2 :X]</code></pre></div><div><span id="escalation-with-defaults" name="escalation-with-defaults"></span><h3><i>6.8.1 &nbsp;&nbsp; Escalation with Defaults</i></h3></div><div><p>This is <code>default</code> in combination with <code>escalate</code> to do some very complex jumping around.</p></div><div class="code"><pre><code class="clojure">(manage                            ;; L2
 [1 2 (manage                      ;; L1
       (raise :A                   ;; L0
              (option :X [] :X))        ;; X
       (on :A []                   ;; H1A
           (escalate
            :B
            (default :X))))]       ;; D1
 (on :B []                        ;; H2B
     (default)))
=&gt; [1 2 :X]</code></pre></div><div class="figure"><a id="escalate-b-choose-default-flow" name="escalate-b-choose-default-flow"></a><h4><i>fig.16  &nbsp;-&nbsp; Escalate :B, Choose Default Flow</i></h4><div class="img"><img height="300px" line="{:row 304, :col 1, :end-row 304, :end-col 117}" src="img/hara_event/escalate_default_x2.png" title="Escalate :B, Choose Default Flow" /></div><p></p></div><div><span id="on-form" name="on-form"></span><h3>6.9 &nbsp;&nbsp; Branch Using On</h3></div><div><p>Customized strategies can also be combined within the <code>on</code> handler. In the following example, it can be seen that the <code>on :error</code> handler supports both <code>escalate</code> and <code>continue</code> strategies.</p></div><div class="code"><pre><code class="clojure">(manage (manage
         (mapv (fn [n]
                 (raise [:error {:data n}]))
               [1 2 3 4 5 6 7 8])
         (on :error [data]
             (if (&gt; data 5)
               (escalate :too-big)
               (continue data))))
        (on :too-big [data]
            (continue (- data))))
=&gt; [1 2 3 4 5 -6 -7 -8]</code></pre></div><div><p>Using branching strategies with <code>on</code> much more complex interactions can be constructed beyond the scope of this document.</p></div><div><span id="implementation" name="implementation"></span><h2><b>7 &nbsp;&nbsp; Implementation</b></h2></div><div><p>Two macros - <code>raise</code> and <code>manage</code> work together in creating the illusion of allowing code to seemingly jump around between higher and lower level functions. This in reality is not the case at all. We revisit the analogy of the worker who comes across something in their everyday routine that they cannot process.</p></div><div><span id="the-dumb-throw" name="the-dumb-throw"></span><h3>7.1 &nbsp;&nbsp; The dumb throw</h3></div><div><p>When <code>&#40;throw .....&#41;</code> is invoked, the worker basically says: <em>'Dude, I quit! You deal with it'</em> and lets higher up managers deal with the consequences.</p></div><div class="figure"><a id="lazy-worker" name="lazy-worker"></a><h4><i>fig.17  &nbsp;-&nbsp; Lazy Worker</i></h4><div class="img"><img height="300px" line="{:row 12, :col 1, :end-row 12, :end-col 87}" src="img/hara_event/work_throw.png" title="Lazy Worker" /></div><p></p></div><div><span id="the-smart-raise" name="the-smart-raise"></span><h3>7.2 &nbsp;&nbsp; The smart raise</h3></div><div><p>When <code>&#40;raise ....&#41;</code> is used, the worker will attempt to notify their manager and ask for instructions. Only when there are no instructions forthcoming will they quit:</p></div><div class="code"><pre><code class="clojure">(defn dislike-odd [n]
  (if (odd? n) (raise :error) n))

(manage
 (mapv dislike-odd (range 10))
 (on :error [] (continue :odd)))
=&gt; [0 :odd 2 :odd 4 :odd 6 :odd 8 :odd]</code></pre></div><div><p>Purely from looking at the example code, it reads:</p><ul><li>perform <code>mapv</code> of <code>dislike-odd</code> over the range of 0 to 10</li><li>if <code>:error</code> is raised by <code>dislike-odd</code>, tell <code>dislike-odd</code> to proceed at the point that the error was raised, using the value <code>:odd</code> instead.</li></ul></div><div class="figure"><a id="smart-worker" name="smart-worker"></a><h4><i>fig.18  &nbsp;-&nbsp; Smart Worker</i></h4><div class="img"><img height="300px" line="{:row 36, :col 1, :end-row 36, :end-col 88}" src="img/hara_event/work_raise.png" title="Smart Worker" /></div><p></p></div><div><p>Anytime there is an odd input to <code>dislike-odd</code>, the code seemingly jumps out to the context of the manager and having handled the issue, the code then seemingly jumps back into the function again.</p><p>Note the words <code>seemingly</code>. This is how we as programmers should be thinking about the problem as we write code to handle these type of issues. We are tricked for our own good because it makes us able to better reason about our programs without having to deal with the implementation details.</p><p>However, we are naturally suspicious of this from a performance point of view. If we don't know the mechanism, we ask ourselves... won`t all this jumping around make our code slower?</p></div><div><span id="being-proactive" name="being-proactive"></span><h3>7.3 &nbsp;&nbsp; Being Proactive</h3></div><div><p>In reality, the program never left the place where <code>raise</code> was called. There was no saving of the stack or anything fancy. The <code>raise/continue</code> combination was an <em>illusion</em> of a jump. There was no jump. Calling <code>raise/continue</code> is most likely computationally cheaper than <code>try/catch</code>.</p><p>Going back to the workplace analogy, another way to manage exceptional circumstances is to have a prearranged noticeboard of what to do when things go wrong. Managers can write/override different ways to handle an issue on this board proactively. The worker, when encountering an issue, would go look at the board first to decide upon the best course of action to take. Only when there are no matching solutions to the issue will they solve it themselves or give up and quit. In this way, managers will not have to be called everytime something came up. This is the same mechanism of control that <code>hara.event</code> uses.</p></div><div class="figure"><a id="proactive-management" name="proactive-management"></a><h4><i>fig.19  &nbsp;-&nbsp; Proactive Management</i></h4><div class="img"><img height="300px" line="{:row 53, :col 1, :end-row 53, :end-col 96}" src="img/hara_event/work_board.png" title="Proactive Management" /></div><p></p></div><div><span id="the-issue-management-board" name="the-issue-management-board"></span><h3>7.4 &nbsp;&nbsp; The Issue Management Board</h3></div><div><p>We look at what happens when there is such an Issue Management Board put in place. <code>raise</code> is called. The worker will look at the board, starting with lowest level manager and proceeding up the management chain to see what strategies has to be been put into place. In the case of <a href='#continue-example'>e.</a>, there would have been a handler already registered on the board to deal with the <code>:error</code>. The worker will pass any arguments of the issue to the handler function and then return with the result.</p></div><div class="figure"><a id="img-img--hara-event--notice-board-png" name="img-img--hara-event--notice-board-png"></a><div class="img"><img height="300px" line="{:row 61, :col 1, :end-row 61, :end-col 68}" src="img/hara_event/notice_board.png" /></div><p></p></div><div><p>The management does not even need to know that an exception has occured because they have been proactive.</p></div><div><span id="control-flow-as-data" name="control-flow-as-data"></span><h3>7.5 &nbsp;&nbsp; Control Flow as Data</h3></div><div><p>Whilst the <code>raise/continue</code> mechanism was decribed in brief, a bit more explanation is required to understand how different forms of jumps occur. The 5 special forms are implemented as data-structures:</p></div><div class="code"><pre><code class="clojure">(defmacro continue [&amp; body]
  `{::type :continue ::value (do ~@body)})

(defmacro default [&amp; args]
  `{::type :default ::args (list ~@args)})

(defmacro choose [label &amp; args]
  `{::type :choose ::label ~label ::args (list ~@args)})

(defmacro fail
  ([] {::type :fail})
  ([contents]
     `{::type :fail ::contents ~contents}))</code></pre></div><div><p><code>escalate</code> is not shown because it a bit more complex as options and defaults can. Essentially, it is still just a data structure.</p><p>The <code>raise</code> macro calls <code>raise-loop</code> which looks at the <code>::type</code> signature of the result returned by the <code>on</code> handler.</p></div><div class="code"><pre><code class="clojure">(defn raise-loop [issue managers optmap]
  (... code ...
       (condp = (::type res)
         :continue (::value res)
         :choose (raise-choose issue (::label res) (::args res) optmap)
         :default (raise-unhandled issue optmap)
         :fail (raise-fail issue (::contents res))
         :escalate (raise-escalate issue res managers optmap)
         (raise-catch mgr res)))

  ... code ...)</code></pre></div><div><p>In the case of <code>:continue</code>, it can be seen that the function just returns <code>&#40;::value res&#41;</code>. The function in which <code>raise</code> was called proceeds without ever jumping anywhere.</p><p>In the case of other forms, there are different handlers to handle each case. If the <code>on</code> handler returns a non-special form value, it will call <code>raise-catch</code>. So it is possible to mess with the internals of <code>hara.event</code> by creating a datastructure of the same format of the special forms.</p></div><div><span id="implementing-catch" name="implementing-catch"></span><h3>7.6 &nbsp;&nbsp; Implementing Catch</h3></div><div><p>To understand how <code>catch</code> is implemented, we have to look at the <code>manage</code> macro:</p></div><div class="code"><pre><code class="clojure">(defmacro manage
  ... code ...

  `(binding [*managers* (cons ~manager *managers*)
             *optmap* (merge ~optmap *optmap*)]
     (try
       ~@body-forms
       (catch clojure.lang.ExceptionInfo ~'ex
         (manage-signal ~manager ~'ex))
       ~@finally-forms)))</code></pre></div><div><p>So essentially, it is a <code>try/catch</code> block wrapped in an <code>binding</code> form.</p></div><div><p>When <code>raise-loop</code> gets a non-special form value back from a function handler in the manager it will call <code>raise-catch</code>, which will create a <code>catch</code> signal and actually throw it. The signal is just a clojure.lang.ExceptionInfo. The signal has a <code>::target</code>, which is the <code>:id</code> of the manager. It also has <code>::value</code>, which is the original result from <code>on</code>.</p></div><div class="code"><pre><code class="clojure">(defn- raise-catch [manager value]
  (throw (create-catch-signal (:id manager) value)))

(defn- create-catch-signal
  [target value]
  (ex-info &quot;catch&quot; {::signal :catch ::target target ::value value}))</code></pre></div><div><p>Going back to the <code>manage</code> block, it can be seen that <code>manage</code> will catch any <code>clojure.lang.ExceptionInfo</code> objects thrown. When a signal is thrown from lower functions, it will be caught and <code>manage-signal</code> is then called. If the target does not match the :id, then the exception is rethrown. If the exception has <code>::signal</code> of <code>:catch</code> then the manager will return <code>&#40;::value data&#41;</code>.</p></div><div class="code"><pre><code class="clojure">(defn manage-signal [manager ex]
  (let [data (ex-data ex)]
    (cond (not= (:id manager) (::target data))
          (throw ex)

          ... choose code ....

          (= :catch (::signal data))
          (::value data)

          :else (throw ex))))</code></pre></div><div><span id="implementing-choose" name="implementing-choose"></span><h3>7.7 &nbsp;&nbsp; Implementing Choose</h3></div><div><p>Choose works with options. It can be seen that apart from the <code>&#42;managers&#42;</code> structure, there is also an <code>&#42;optmap&#42;</code>. The optmap holds as the key/value pairs the labels of what options are registered and the id of the manager that provided the option.</p><p>Choose also requires that a signal be sent, but the target will now be a lookup on the optmap given an option label. The signal is very similar to the <code>catch</code> signal.</p></div><div class="code"><pre><code class="clojure">(defn- create-choose-signal
  [target label args]
   (ex-info &quot;choose&quot; {::signal :choose ::target target ::label label ::args args}))</code></pre></div><div><p>The part that processes <code>:choose</code> is shown in <code>manage-signal</code>:</p></div><div class="code"><pre><code class="clojure">(defn manage-signal
   ...
     (= :choose (::signal data))
     (let [label (::label data)
           f (get (:options manager) label)
           args (::args data)]
       (manage-apply f args label))
  ...)</code></pre></div><div><span id="implementing-the-rest" name="implementing-the-rest"></span><h3>7.8 &nbsp;&nbsp; Implementing the Rest</h3></div><div><p><code>fail</code>, <code>default</code>, <code>escalate</code> all use similar <em>data as control-flow</em> mechanisms to allow control to be directed to the correct part of the program. It is through this mechanism that branching in the <code>on</code> handlers can be achieved.</p></div><div><span id="links-and-resources" name="links-and-resources"></span><h2><b>8 &nbsp;&nbsp; Links and Resources</b></h2></div><div><p>Here are some more links and resources on the web:</p><ul><li><a href='http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html'>beyond exception handling</a> - Peter Seibel's chapter on conditional restarts</li><li><a href='http://z.caudate.me/why-exceptions-are-like-stylesheets/'>why exceptions should cascade like stylesheets</a> - original article on the philosophy behind <a href='http://www.github.com/zcaudate/ribol'>ribol</a></li><li><a href='http://www.youtube.com/watch?v=GDVAHA0oyJU'>the power of abstraction</a> - excellent talk by Barbara Liskov</li></ul></div>
        </div>
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

  </body>

  <script type="text/javascript">
    smoothScroll.init();
    gumshoe.init({});
  
    hljs.registerLanguage("clojure",function(e){var t={"builtin-name":"def defonce cond apply if-not if-let if not not= = < > <= >= == + / * - rem quot neg? pos? delay? symbol? keyword? true? false? integer? empty? coll? list? set? ifn? fn? associative? sequential? sorted? counted? reversible? number? decimal? class? distinct? isa? float? rational? reduced? ratio? odd? even? char? seq? vector? string? map? nil? contains? zero? instance? not-every? not-any? libspec? -> ->> .. . inc compare do dotimes mapcat take remove take-while drop letfn drop-last take-last drop-while while intern condp case reduced cycle split-at split-with repeat replicate iterate range merge zipmap declare line-seq sort comparator sort-by dorun doall nthnext nthrest partition eval doseq await await-for let agent atom send send-off release-pending-sends add-watch mapv filterv remove-watch agent-error restart-agent set-error-handler error-handler set-error-mode! error-mode shutdown-agents quote var fn loop recur throw try monitor-enter monitor-exit defmacro defn defn- macroexpand macroexpand-1 for dosync and or when when-not when-let comp juxt partial sequence memoize constantly complement identity assert peek pop doto proxy defstruct first rest cons defprotocol cast coll deftype defrecord last butlast sigs reify second ffirst fnext nfirst nnext defmulti defmethod meta with-meta ns in-ns create-ns import refer keys select-keys vals key val rseq name namespace promise into transient persistent! conj! assoc! dissoc! pop! disj! use class type num float double short byte boolean bigint biginteger bigdec print-method print-dup throw-if printf format load compile get-in update-in pr pr-on newline flush read slurp read-line subvec with-open memfn time re-find re-groups rand-int rand mod locking assert-valid-fdecl alias resolve ref deref refset swap! reset! set-validator! compare-and-set! alter-meta! reset-meta! commute get-validator alter ref-set ref-history-count ref-min-history ref-max-history ensure sync io! new next conj set! to-array future future-call into-array aset gen-class reduce map filter find empty hash-map hash-set sorted-map sorted-map-by sorted-set sorted-set-by vec vector seq flatten reverse assoc dissoc list disj get union difference intersection extend extend-type extend-protocol int nth delay count concat chunk chunk-buffer chunk-append chunk-first chunk-rest max min dec unchecked-inc-int unchecked-inc unchecked-dec-inc unchecked-dec unchecked-negate unchecked-add-int unchecked-add unchecked-subtract-int unchecked-subtract chunk-next chunk-cons chunked-seq? prn vary-meta lazy-seq spread list* str find-keyword keyword symbol gensym force rationalize"},r="a-zA-Z_\\-!.?+*=<>&#'",n="["+r+"]["+r+"0-9/;:]*",a="[-+]?\\d+(\\.\\d+)?",o={b:n,r:0},s={cN:"number",b:a,r:0},i=e.inherit(e.QSM,{i:null}),c=e.C(";","$",{r:0}),d={cN:"literal",b:/\b(true|false|nil)\b/},l={b:"[\\[\\{]",e:"[\\]\\}]"},m={cN:"comment",b:"\\^"+n},p=e.C("\\^\\{","\\}"),u={cN:"symbol",b:"[:]{1,2}"+n},f={b:"\\(",e:"\\)"},h={eW:!0,r:0},y={k:t,l:n,cN:"name",b:n,starts:h},b=[f,i,m,p,c,u,l,s,d,o];return f.c=[e.C("comment",""),y,h],h.c=b,l.c=b,{aliases:["clj"],i:/\S/,c:[f,i,m,p,c,u,l,s,d]}});
    hljs.initHighlightingOnLoad();
  </script>
</html>
